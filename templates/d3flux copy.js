var {{ figure_id }}model = {{ modeljson }};

require.config({
  paths: {
    d3: "../include/d3.v3.min",
    cola: "../include/cola.min",
    math: "../include/math.min",
    FileSaver: "../include/FileSaver.min",
    point2d: "../include/point2d",
  },
  shim: {
    'cola': {
      exports: 'cola'
    }
  }
});

require(["cola", "d3", "math", "FileSaver", "point2d", ], function (cola, d3, math, FileSaver) {

  function main(model) {
    // Render a metabolic network representation of a cobra.Model object.
    //
    // `model` is a json-serialized representation of a metabolic network,
    // generated by cobra.display.flux_analysis.create_model_json

    // Height and width of the SVG figure, passed via jinja2
    var width = {{ figwidth }},
    height = {{ figheight }};

    // var color = d3.scale.category10();

    // Reaction color allows different reaction groups to be colored
    // accordingly. Grouping is mainly handled by color_redox_reactions. First
    // group ('undefined') is for normal reactions (gray). Second group is for
    // knocked-out reactions, (red). Others are rendered in different
    // contrasting colors
    var rxncolor = d3.scale.ordinal()
      // .range(["#bbb", "#d62728", "#ff7f0e", "#2ca02c", "#9467bd",
      //         "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"])
      .range(["#bbb", "#d62728",
        "#eb6a9b",
        "#6f3589",
        "#f18572",
        "#246035",
        "#009fea",
        "#83522b",
        "#29378a",
        "#989033"])
      .domain([undefined, 'ko', 1, 2, 3, 4, 5, 6, 7, 8]);

    // Initialize the d3 force diagram. Parameters like charge, gavity, and
    // link distance are currently hard-coded in -- probably should change
    // this?
    var force = cola.d3adaptor()
      .linkDistance(30)
      {% if flowLayout %}
      .flowLayout('y', 15)
      {% endif %}
      .size([width, height]);
    // var force = d3.layout.force()
    //   .linkDistance(30)
    //   .charge(-100)
    //   .chargeDistance(400)
    //   .gravity(.015)
    //   .size([width, height]);

    // Allow for a background SVG template if one has been provided, otherwise
    // initalize the svg canvas
    if ({{ no_background }}) {
      var svg = d3.select("#{{ figure_id }}").append("svg")
        .attr("viewBox", "0 0 {{ figwidth }} {{ figheight }}")
        .attr("style", "display:block;margin:auto;width:{{ svg_scale }}%");
    } else {
      var svg = d3.select("#{{ figure_id }}").select("svg");
    }

    // Append the CSS styles
    svg.append("style").text('{{ css }}');


    // Zoom function
    svg_panel = d3.select("#svg_panel");
    var zoom = d3.behavior.zoom().scaleExtent([0.5, 4]).on("zoom", zoomed);
    function zoomed() {
      svg.attr("transform",
          "translate(" + zoom.translate() + ")" +
          "scale(" + zoom.scale() + ")"
      );
    }
  
    function interpolateZoom (translate, scale) {
        var self = this;
        return d3.transition().duration(350).tween("zoom", function () {
            var iTranslate = d3.interpolate(zoom.translate(), translate),
                iScale = d3.interpolate(zoom.scale(), scale);
            return function (t) {
                zoom
                    .scale(iScale(t))
                    .translate(iTranslate(t));
                zoomed();
            };
        });
    }

    function zoomClick() {
      var clicked = d3.event.target,
          direction = 1,
          factor = 0.2,
          target_zoom = 1,
          center = [width / 2, height / 2],
          extent = zoom.scaleExtent(),
          translate = zoom.translate(),
          translate0 = [],
          l = [],
          view = {x: translate[0], y: translate[1], k: zoom.scale()};
  
      d3.event.preventDefault();
      direction = (this.id === 'zoom_in') ? 1 : -1;
      target_zoom = zoom.scale() * (1 + factor * direction);
  
      if (target_zoom < extent[0] || target_zoom > extent[1]) { return false; }
  
      translate0 = [(center[0] - view.x) / view.k, (center[1] - view.y) / view.k];
      view.k = target_zoom;
      l = [translate0[0] * view.k + view.x, translate0[1] * view.k + view.y];
  
      view.x += center[0] - l[0];
      view.y += center[1] - l[1];
  
      interpolateZoom([view.x, view.y], view.k);
  }
  

  var zoomEnabled = false;
  var zoomToggle = d3.select('#cb-zoom').on('click', toggleZoom);
  toggleZoom();

  function toggleZoom() {
    if (zoomEnabled) {
      svg.call(zoom);
    } else {
      svg.on('.zoom', null);
    }
    zoomEnabled = !zoomEnabled;
  };

                        
  d3.selectAll('.zoom_button').on('click', zoomClick);

  // svg.call(zoom);


    d3.select("#{{ figure_id }}_options .svgbutton").on("click", function() { 
      // Download the svg using SVG Crowbar. This is still very buggy.

      var e = document.createElement('script'); 
      e.setAttribute('src', 'https://rawgit.com/pstjohn/svg-crowbar/gh-pages/svg-crowbar.js'); 
      e.setAttribute('class', 'svg-crowbar'); 
      document.body.appendChild(e); 
    });

    function calc_imag_angle(x1, y1, x2, y2) {
      // Function to calculate the imaginary angle of the line between two
      // points. Used to find the average direction to the metabolites of a
      // reaction node
      var calcAngleVal = Math.atan2(x1-x2,y1-y2);
      return math.exp(math.multiply(math.i, calcAngleVal));
    }

    function average_angles(rxn, rstoich, nodes) {
      // Find the slope of the line through the reaction node as a function of
      // the current position of the metabolites. Reactants and products are
      // separated and placed on opposite ends of the nodes.
      //
      // Looks like for cofactors, rstoich could be set to zero to remove the
      // effect on the reaction slope. 
      var angles = []
      for (var n in rstoich) {
        if (!('cofactor' in nodes[n])) {
          var angle = calc_imag_angle(rxn.x, rxn.y, nodes[n].x, nodes[n].y);
          angles.push([math.multiply(angle, rstoich[n])]);
        }
      }
      return math.mean(angles).toPolar().phi;
    }

    function average_dist(rxn, rstoich, nodes) {
      // Calculate the average distance to the reaction nodes, which is used to
      var dist = []
      for (var n in rstoich) {
        var this_dist = math.sqrt(math.square(rxn.x - nodes[n].x) 
            + math.square(rxn.y - nodes[n].y));
        dist.push([this_dist]);
      }
      return math.mean(dist);
    }

    function calculate_path(d, force) {
      var s = d.source,
      t = d.target,
      r = d.rxn,
      a=.1, b=.1,
      cp_inv = {};

      var angle = average_angles(r, d.rstoich, force.nodes());
      var dist = average_dist(r, d.rstoich, force.nodes());

      cp = new Point2D(r.x - math.multiply(.5*dist, math.sin(angle)),
                 r.y - math.multiply(.5*dist, math.cos(angle)));

      cp_inv = new Point2D(r.x + math.multiply(.5*dist, math.sin(angle)),
                     r.y + math.multiply(.5*dist, math.cos(angle)));

      s_point = new Point2D(s.x, s.y)
      r_point = new Point2D(r.x, r.y)
      t_point = new Point2D(t.x, t.y)

      var padding = 5;
      // var total_len = quadraticBezierLength(s, cp, r) + quadraticBezierLength(r, cp_inv, t);


      // Adjust control points to start late and stop early
      if (plot_reverse_arrowhead(d.rxn)) {

        first_intersect = Intersection.intersectBezier2Circle(
    s_point, cp, r_point, s_point, 
    padding + arrowhead_scale(get_flux_width(d.rxn)) + get_node_radius(s)).slice(0)[0];
        last_intersect = Intersection.intersectBezier2Circle(
    r_point, cp_inv, t_point, t_point, 
    padding + arrowhead_scale(get_flux_width(d.rxn)) + get_node_radius(t)).slice(-1)[0];
        a = first_intersect;
        b = last_intersect;

      }
      else {

        first_intersect = Intersection.intersectBezier2Circle(
    s_point, cp, r_point, s_point, padding + get_node_radius(s)).slice(0)[0];
        last_intersect = Intersection.intersectBezier2Circle(
    r_point, cp_inv, t_point, t_point,
    padding + arrowhead_scale(get_flux_width(d.rxn)) + get_node_radius(t)).slice(-1)[0];
        a = first_intersect;
        b = last_intersect;

        // b = 1 - (padding + arrowhead_scale(get_flux_width(d.rxn)))/total_len;
      }
            
      var source_x = s.x*a**2 - 2*s.x*a + s.x - 2*cp.x*a**2 + 2*cp.x*a + r.x*a**2;
      var source_y = s.y*a**2 - 2*s.y*a + s.y - 2*cp.y*a**2 + 2*cp.y*a + r.y*a**2;

      var cp_x = -cp.x*a + cp.x + r.x*a;
      var cp_y = -cp.y*a + cp.y + r.y*a;

      var cp_inv_x = -r.x*b + r.x + cp_inv.x*b
      var cp_inv_y = -r.y*b + r.y + cp_inv.y*b

      var target_x = r.x*b**2 - 2*r.x*b + r.x - 2*cp_inv.x*b**2 + 2*cp_inv.x*b + t.x*b**2;
      var target_y = r.y*b**2 - 2*r.y*b + r.y - 2*cp_inv.y*b**2 + 2*cp_inv.y*b + t.y*b**2;

      if ( isFinite(source_x) & isFinite(cp_x) & isFinite(cp_inv_x) & isFinite(target_x) ) {
        return "M" + source_x + "," + source_y
          + " Q" + cp_x + "," + cp_y
          + " " + r.x + "," + r.y
          + " Q" + cp_inv_x + "," + cp_inv_y
          +" " + target_x + "," + target_y;
      } else {
        return "M" + s.x + "," + s.y
          + " L" + r.x + "," + r.y
          +" L" + t.x + "," + t.y;
      }
    }


// d3.tip
// Copyright (c) 2013 Justin Palmer
//
// Tooltips for d3.js SVG visualizations

// Public - contructs a new tooltip
//
// Returns a tip
d3.tip = function() {
  var direction = d3_tip_direction,
      offset    = d3_tip_offset,
      html      = d3_tip_html,
      node      = initNode(),
      svg       = null,
      point     = null,
      target    = null

  function tip(vis) {
    svg = getSVGNode(vis)
    point = svg.createSVGPoint()
    document.body.appendChild(node)
  }

  // Public - show the tooltip on the screen
  //
  // Returns a tip
  tip.show = function() {
    var args = Array.prototype.slice.call(arguments)
    if(args[args.length - 1] instanceof SVGElement) target = args.pop()

    var content = html.apply(this, args),
        poffset = offset.apply(this, args),
        dir     = direction.apply(this, args),
        nodel   = d3.select(node), i = 0,
        coords

    nodel.html(content)
      .style({ opacity: 1, 'pointer-events': 'all' })

    while(i--) nodel.classed(directions[i], false)
    coords = direction_callbacks.get(dir).apply(this)
    nodel.classed(dir, true).style({
      top: (coords.top +  poffset[0]) + 'px',
      left: (coords.left + poffset[1]) + 'px'
    })

    return tip
  }

  // Public - hide the tooltip
  //
  // Returns a tip
  tip.hide = function() {
    nodel = d3.select(node)
    nodel.style({ opacity: 0, 'pointer-events': 'none' })
    return tip
  }

  // Public: Proxy attr calls to the d3 tip container.  Sets or gets attribute value.
  //
  // n - name of the attribute
  // v - value of the attribute
  //
  // Returns tip or attribute value
  tip.attr = function(n, v) {
    if (arguments.length < 2 && typeof n === 'string') {
      return d3.select(node).attr(n)
    } else {
      var args =  Array.prototype.slice.call(arguments)
      d3.selection.prototype.attr.apply(d3.select(node), args)
    }

    return tip
  }

  // Public: Proxy style calls to the d3 tip container.  Sets or gets a style value.
  //
  // n - name of the property
  // v - value of the property
  //
  // Returns tip or style property value
  tip.style = function(n, v) {
    if (arguments.length < 2 && typeof n === 'string') {
      return d3.select(node).style(n)
    } else {
      var args =  Array.prototype.slice.call(arguments)
      d3.selection.prototype.style.apply(d3.select(node), args)
    }

    return tip
  }

  // Public: Set or get the direction of the tooltip
  //
  // v - One of n(north), s(south), e(east), or w(west), nw(northwest),
  //     sw(southwest), ne(northeast) or se(southeast)
  //
  // Returns tip or direction
  tip.direction = function(v) {
    if (!arguments.length) return direction
    direction = v == null ? v : d3.functor(v)

    return tip
  }

  // Public: Sets or gets the offset of the tip
  //
  // v - Array of [x, y] offset
  //
  // Returns offset or
  tip.offset = function(v) {
    if (!arguments.length) return offset
    offset = v == null ? v : d3.functor(v)

    return tip
  }

  // Public: sets or gets the html value of the tooltip
  //
  // v - String value of the tip
  //
  // Returns html value or tip
  tip.html = function(v) {
    if (!arguments.length) return html
    html = v == null ? v : d3.functor(v)

    return tip
  }

  function d3_tip_direction() { return 'n' }
  function d3_tip_offset() { return [0, 0] }
  function d3_tip_html() { return ' ' }

  var direction_callbacks = d3.map({
    n:  direction_n,
    s:  direction_s,
    e:  direction_e,
    w:  direction_w,
    nw: direction_nw,
    ne: direction_ne,
    sw: direction_sw,
    se: direction_se
  }),

  directions = direction_callbacks.keys()

  function direction_n() {
    var bbox = getScreenBBox()
    return {
      top:  bbox.n.y - node.offsetHeight,
      left: bbox.n.x - node.offsetWidth / 2
    }
  }

  function direction_s() {
    var bbox = getScreenBBox()
    return {
      top:  bbox.s.y,
      left: bbox.s.x - node.offsetWidth / 2
    }
  }

  function direction_e() {
    var bbox = getScreenBBox()
    return {
      top:  bbox.e.y - node.offsetHeight / 2,
      left: bbox.e.x
    }
  }

  function direction_w() {
    var bbox = getScreenBBox()
    return {
      top:  bbox.w.y - node.offsetHeight / 2,
      left: bbox.w.x - node.offsetWidth
    }
  }

  function direction_nw() {
    var bbox = getScreenBBox()
    return {
      top:  bbox.nw.y - node.offsetHeight,
      left: bbox.nw.x - node.offsetWidth
    }
  }

  function direction_ne() {
    var bbox = getScreenBBox()
    return {
      top:  bbox.ne.y - node.offsetHeight,
      left: bbox.ne.x
    }
  }

  function direction_sw() {
    var bbox = getScreenBBox()
    return {
      top:  bbox.sw.y,
      left: bbox.sw.x - node.offsetWidth
    }
  }

  function direction_se() {
    var bbox = getScreenBBox()
    return {
      top:  bbox.se.y,
      left: bbox.e.x
    }
  }

  function initNode() {
    var node = d3.select(document.createElement('div'))
    node.style({
      position: 'absolute',
      opacity: 0,
      pointerEvents: 'none',
      boxSizing: 'border-box'
    })

    return node.node()
  }

  function getSVGNode(el) {
    el = el.node()
    if(el.tagName.toLowerCase() == 'svg')
      return el

    return el.ownerSVGElement
  }

  // Private - gets the screen coordinates of a shape
  //
  // Given a shape on the screen, will return an SVGPoint for the directions
  // n(north), s(south), e(east), w(west), ne(northeast), se(southeast), nw(northwest),
  // sw(southwest).
  //
  //    +-+-+
  //    |   |
  //    +   +
  //    |   |
  //    +-+-+
  //
  // Returns an Object {n, s, e, w, nw, sw, ne, se}
  function getScreenBBox() {
    var targetel   = target || d3.event.target,
        bbox       = {},
        matrix     = targetel.getScreenCTM(),
        tbbox      = targetel.getBBox(),
        width      = tbbox.width,
        height     = tbbox.height,
        x          = tbbox.x,
        y          = tbbox.y,
        scrollTop  = document.documentElement.scrollTop || document.body.scrollTop,
        scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft


    point.x = x + scrollLeft
    point.y = y + scrollTop
    bbox.nw = point.matrixTransform(matrix)
    point.x += width
    bbox.ne = point.matrixTransform(matrix)
    point.y += height
    bbox.se = point.matrixTransform(matrix)
    point.x -= width
    bbox.sw = point.matrixTransform(matrix)
    point.y -= height / 2
    bbox.w  = point.matrixTransform(matrix)
    point.x += width
    bbox.e = point.matrixTransform(matrix)
    point.x -= width / 2
    point.y -= height / 2
    bbox.n = point.matrixTransform(matrix)
    point.y += height
    bbox.s = point.matrixTransform(matrix)

    return bbox
  }

  return tip
};



    // _note: return a boolean of whether to draw reverse arrowhead
    function plot_reverse_arrowhead(rxn) {
     return (((Math.abs(rxn.notes.map_info.flux) < 1E-8) || isNaN(rxn.notes.map_info.flux))
      && rxn.notes.map_info.reversibility);
    }

    // _note: need to distinguish links and bilinks
    // _ans: links include the edge between a source node and a reaction node.
    metabolites = jQuery.extend(true, [], model.metabolites),
    reactions = jQuery.extend(true, [], model.reactions),
    nodes = [],
    node_lookup = {},
    links = [],
    mlinks = [],
    bilinks = []
    rxn_stoich = {};

    var mfluxes = [];
    metabolites.forEach(function(metabolite) {
      if ('notes' in metabolite) {
        if ('map_info' in metabolite.notes) {
          if (metabolite.notes.map_info.hidden) {
            return;
          } else {
            if ({{ hide_unused }} && (Math.abs(metabolite.notes.map_info.flux) < 1E-6)) {
              return;
            }
            mfluxes.push(Math.abs(metabolite.notes.map_info.flux));
          }
        }
      }
      // It's not hidden, add it to the nodes
      metabolite.type = "metabolite";
      nodes.push(metabolite);
    });

    // Create a dictionary-like structure to allow us to look up nodes by their
    // id, rather than numerical index
    for (var i = 0, len = nodes.length; i < len; i++) {
      var node = nodes[i]
      node_lookup[node.id] = i;
    }

    // Handle cofactor metabolites
    reactions.forEach(function(reaction) {
      if ('notes' in reaction) {
        if ('map_info' in reaction.notes) {
          if ('hidden' in reaction.notes.map_info) {
            if (reaction.notes.map_info.hidden) {
              return;
            }
          }
          if ({{ hide_unused_cofactors }} &&
              (Math.abs(reaction.notes.map_info.flux) < 1E-6)) {
            return;
          } 
          if ('cofactors' in reaction.notes.map_info) {
            for (var cofactor in reaction.notes.map_info.cofactors) {

              var orig_metabolite = obj = $.grep(model.metabolites,
                  function(e){ return e.id == cofactor; })[0];
              var cf_id = cofactor + '_' + reaction.id;

              var cofactor_node = {
                'id' : cf_id,
                'name' : orig_metabolite.name,
                'type' : "cofactor",
                'notes' : {
                  'map_info' : reaction.notes.map_info.cofactors[cofactor],
                  'orig_id' : cofactor
                },
                'cofactor' : reaction.id
              };

              if ('flux' in orig_metabolite.notes.map_info) {
                cofactor_node.notes.map_info['flux'] = orig_metabolite.notes.map_info.flux;
              }

              // Inheret color from original metabolite
              if ('color' in orig_metabolite.notes.map_info) {
                cofactor_node.notes.map_info.color = 
                  orig_metabolite.notes.map_info.color;
              }

              // Get the cofactor display name from the original 
              // metabolite node
              if ('map_info' in orig_metabolite.notes) {
                if (('display_name' in orig_metabolite.notes.map_info) &
	            !('display_name' in cofactor_node.notes.map_info)) {
                  cofactor_node.notes.map_info.display_name =
                    orig_metabolite.notes.map_info.display_name;
                }
              }

              reaction.metabolites[cf_id] = reaction.metabolites[cofactor];
              delete reaction.metabolites[cofactor];

              // Update nodes and node_lookup table
              nodes.push(cofactor_node);
              node_lookup[cf_id]  = nodes.length - 1;

            }
          }
        }
      }
    });


    // Create a dictionary-like structure to allow us to look up nodes by their
    // id, rather than numerical index
    // for (var i = 0, len = nodes.length; i < len; i++) {
    //   var node = nodes[i]
    //   node_lookup[node.id] = i;
    // }

    var fluxes = [];
    reactions.forEach(function(reaction) {

      // Don't add hidden reactions
      if ('notes' in reaction) {
        if ('map_info' in reaction.notes) {
          if (reaction.notes.map_info.hidden) {
            return;
          } else if ('flux' in reaction.notes.map_info) {
            if ({{ hide_unused }} && (Math.abs(reaction.notes.map_info.flux) < 1E-6)) {
              return;
            }
            fluxes.push(Math.abs(reaction.notes.map_info.flux));
            if (reaction.notes.map_info.flux < -1E-10) {
              // If the reaction is flowing in reverse, switch products and
              // reactants.
              for (var item in reaction.metabolites) {
                reaction.metabolites[item] *= -1;
              }
            }
          }
        }
      }

      // !important
      reaction['reactants'] = []
      reaction['products'] = []

      for (var item in reaction.metabolites) {
        if (reaction.metabolites[item] > 0) {
          if (item in node_lookup) {
            // _notes: reaction.metabolites[item] = 1 -> product, = -1 -> reactant
            // Only add if the node hasn't been hidden
            reaction.products.push(item);
          }
        } else if (item in node_lookup) {
          reaction.reactants.push(item);
        }
      }

      var r_length = reaction.reactants.length,
      p_length = reaction.products.length,
      r_node = {
        "id" : reaction.id,
        "type" : "rxn"
      };

      // Add notes to reaction, if it exists (for map_info)
      if ("notes" in reaction) {
        r_node["notes"] = reaction.notes;
      }

      // Don't add links on the boundary
      if (r_length == 0 || p_length == 0) {
        return; 
      }

      // Add reaction to the nodes list, get the current length of the nodes
      // list as the reaction index for later.
      nodes.push(r_node);
      rindex = nodes.length - 1;


      // !important: drawing
      if (r_length >= p_length) {
        reaction.reactants.forEach(function (reactant, i) {
          // Add source -> rxn -> product triplets for drawing the line. For
          // each reactant (product), just get any product (reactant), as the
          // lines will overlap)
          mlinks.push({
            "source" : node_lookup[reactant],
            // _note: ? i % p_length - 1 ？
            "target" : node_lookup[reaction.products[i % p_length]],
            "rxn" : rindex
        });
      });
      } // else: products > reactants
      else {
        reaction.products.forEach(function (product, i) {
          mlinks.push({
            "source" : node_lookup[reaction.reactants[i % r_length]],
            "target" : node_lookup[product],
            "rxn" : rindex
          });
        });
      }

    });

    // Build the reaction stoichiometry database to remember which nodes are
    // reactants and which are products. Used to calculate path angles.
    // _note: rxn_stoich is the database.
    mlinks.forEach(function(link) {
      if (link.rxn in rxn_stoich) {
        rxn_stoich[link.rxn][link.source] = 1;
        rxn_stoich[link.rxn][link.target] = -1;
      } else {
        rxn_stoich[link.rxn] = {};
        rxn_stoich[link.rxn][link.source] = 1;
        rxn_stoich[link.rxn][link.target] = -1;
      }
    });

    mlinks.forEach(function(link, i) {
      var s = nodes[link.source],
      t = nodes[link.target],
      r = nodes[link.rxn];

      // _note: push 2 objects into links
      links.push({source: s, target: r}, {source: r, target: t});
      //_note: bilinks stand for what?
      bilinks.push({
        "source" : s,
        "target" : t,
        "rxn" : r,
        "rstoich" : rxn_stoich[link.rxn],
        "id": "bilink_" + i
      });
    });

    nodes.forEach( function (node) {
      if ("notes" in node) {
        if ("map_info" in node.notes) {
          if (("x" in node.notes.map_info) && ("y" in node.notes.map_info)) {
            node.x = node.notes.map_info.x;
            node.y = node.notes.map_info.y;
            node.fixed = 1;
          }
        }
      }
    });



    // Modify link strength based on flux:
    // link_strength_scale = d3.scale.pow().exponent(1/2)
    // link_strength_scale = d3.scale.linear()
    //   .domain([d3.min(fluxes), d3.max(fluxes)])
    //   .range([.2, 2]);
    //
    // force
    //   .linkStrength(function (link) {
    //     try {
    //       return link.rxn.notes.map_info.flux;
    //     }
    //     catch(err) {
    //       return 1;
    //     }
    //   });

    force
      .nodes(nodes)
      .links(links)
      .start();

    svg.append("defs").selectAll("marker")
      .data(reactions)
      .enter()
      .append("marker")
      .attr("id", function (d) { return "{{ figure_id }}" + d.id; })
      .attr("viewBox", "0 0 10 10")
      .attr("refX", 1)
      .attr("refY", 5)
      .attr("markerUnits", "userSpaceOnUse")
      .attr("markerWidth", "7pt")
      .attr("markerHeight", "7pt")
      .attr("orient", "auto")
      .attr("class", function (d) {
        var labels = "endmarker"
        if ('flux' in d.notes.map_info) {
          // _note: flux = 0 means this reaction is inactive
          if (d.notes.map_info.flux == 0) {
            labels = labels.concat(" inactive");
          }
        }
        return labels;
      })
      .append("path")
      .attr("d", "M 0 0 L 10 5 L 0 10 z");

    svg.append("defs").selectAll("marker")
      .data(reactions)
      .enter()
      .append("marker")
      .attr("id", function (d) { return "{{ figure_id }}" + d.id + "_rev"; })
      .attr("viewBox", "0 0 10 10")
      .attr("refX", 9)
      .attr("refY", 5)
      .attr("markerUnits", "userSpaceOnUse")
      .attr("markerWidth", "7pt")
      .attr("markerHeight", "7pt")
      .attr("orient", "auto")
      .attr("class", function (d) {
        var labels = "startmarker"
        if ('flux' in d.notes.map_info) {
          if (d.notes.map_info.flux == 0) {
            labels = labels.concat(" inactive");
          }
        }
        return labels;
      })
      .append("path")
      .attr("d", "M 10,10 0,5 10,0 Z");

    var link = svg.append('g').selectAll(".link")
      .data(bilinks)
      .enter()
      .append("path")
      .attr("class", function (d) {
        var labels = "link {{ figure_id }}" + d.rxn.id;
        if ('flux' in d.rxn.notes.map_info) {
          if (d.rxn.notes.map_info.flux == 0) {
            // _note: use labels to select the link.
            labels = labels.concat(" inactive");
          }
        }
        return labels;
      })
      .attr("id", function (d) {
        return d.id;
      })
      .attr("marker-end", function(d) {
        return "url(#{{ figure_id }}" + d.rxn.id + ")"; 
      })
      .attr("marker-start", function(d) {
  // Only show the reversible arrow if the reaction isnt carrying flux in
  // a particular direction
        if (plot_reverse_arrowhead(d.rxn)) {
    return "url(#{{ figure_id }}" + d.rxn.id + "_rev)";
  }
      });



    var node_drag = force.drag()
      .on("dragstart", dragstart);

    function dragstart(d) {
      d3.select(this).classed("fixed", d.fixed = true);
    }

    function releasenode(d) {
      // of course set the node to fixed so the force doesn't include the node in
      // its auto positioning stuff
      d.fixed = false; 
      force.resume();
    }

    function showInfo(d) {
      return d.id;
    }



// Node hover tooltip
var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([10, 0])
  .direction('s')
  .html(function (d) {
    if (d.type == "metabolite") {
      return "<strong>Metabolite:</strong> <span style='color:red'>" + d.id + "</span>" + "<br/><br/>" +
      "<strong>Name:</strong> <span style='color:red'>" + d.name + "</span>" + "<br/><br/>" +
      "<strong>Formula:</strong> <span style='color:red'>" + d.formula + "</span>" + "<br/><br/>" +
      "<strong>Charge:</strong> <span style='color:red'>" + d.charge + "</span>";
    } else
    if (d.type == "rxn") {
      return "<strong>Reaction:</strong> <span style='color:red'>" + d.id + "</span>" + "<br/><br/>" +
      "<strong>Enzymes:</strong> <span style='color:red'>" + d.notes.Enzymes + "</span>" + "<br/><br/>" +
      "<strong>KEGG:</strong> <span style='color:red'>" + d.notes.KEGG + "</span>" + "<br/><br/>" +
      "<strong>MetaCyc:</strong> <span style='color:red'>" + d.notes.MetaCyc + "</span>" + "<br/><br/>" +
      "<strong>original_bigg_id:</strong> <span style='color:red'>" + d.notes.original_bigg_id + "</span>";
    } else
    if (d.type == "cofactor") {
      return "<strong>Cofactor:</strong> <span style='color:red'>" + d.id + "</span>" + "<br/><br/>" +
      "<strong>Name:</strong> <span style='color:red'>" + d.name + "</span>";
    }

    return "<strong>Node:</strong> <span style='color:red'>" + d.id + "</span>";
  })

  // Enable or disable tooltip
  var tipEnalbed;
  var tipToggle = d3.select('#cb-tip').on('click', toggleTip);
  toggleTip();

  function toggleTip(){
    console.log("cb-tip clicked!");
    var node = svg.selectAll(".node");
    tipEnalbed = !tipEnalbed;
    if (tipEnalbed) {
        svg.call(tip);
        node.on('mouseover', tip.show);
        node.on('mouseout', tip.hide);
    } else {
        node.on('mouseover', null);
        node.on('mouseout', null);
    }
    zoomToggle.node().innerText = 'Zoom is ' + (zoomEnabled ? 'enabled' : 'disabled');
}; 

  // svg.call(tip);

    // define the nodes
    var node = svg.append("g").selectAll(".node")
      .data(nodes)
      .enter()
      .append("g")
      .on('dblclick', releasenode)
      .call(node_drag)
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      // hari: how node info on click
      .on("click", function (d) {
        d3.select("#info")
        .property("value", d.id);
        console.log(d.id);
      });


    node.append("circle")
      .attr("class", function(d) {
        var labels = "node";
        if (d.type == 'rxn') {
          labels = labels.concat(" " + d.type + " hidden");
        } else {
          labels = labels.concat(" metabolite");
        }
        if ('flux' in d.notes.map_info) {
          if (d.notes.map_info.flux == 0) {
            labels = labels.concat(" inactive");
          }
        }
        return labels;
      })
      .attr("id", function(d) { return "_" + d.id; })
      .attr("r", 5)
      .style("fill", function(d) { 
        if (d.type != 'rxn') {
          if ('color' in d.notes.map_info) {
            return d.notes.map_info.color;
          } else {
            return '#1f77b4';
          }
        } else return "";
      });

    
    // test            
    // add the text 
    var text = node.append("text")
      .attr("class", function(d) {
        var labels = "nodelabel";
        if ('cofactor' in d) {
          labels = labels.concat(" cofactor");
        }
        if ('flux' in d.notes.map_info) {
          if (d.notes.map_info.flux == 0) {
            labels = labels.concat(" inactive");
          }
        }
        if (d.type == 'rxn') {
	  labels = labels.concat(" rxn");
        }
        return labels;
      })
      .attr("id", function(d) {return d.id})

      .attr("y", function(d) {
        if ('align' in d.notes.map_info) {
          if (d.notes.map_info.align.indexOf("upper") !== -1) {
            return '-.65em';
          }
          else if (d.notes.map_info.align.indexOf("lower") !== -1) {
            return '1.35em';
          }
          else {
            return '.35em';
          }
        } else {
          return '.35em';
        }
      })
      .attr("text-anchor", function(d) {
        if ('align' in d.notes.map_info) {
          if (d.notes.map_info.align.indexOf("left") !== -1) {
            return 'end';
          }
          else if (d.notes.map_info.align.indexOf("center") !== -1) {
            return 'middle';
          }
          else {
            return 'start';
          }
        } else {
          return 'start';
        }
      });
      // .text(function(d) { 
      //   if ('map_info' in d.notes) {
      //     if ('display_name' in d.notes.map_info) {
      //       return d.notes.map_info.display_name;
      //     }}});
      
    text.selectAll("tspan.text")
      .data(function(d) { 
        if ('map_info' in d.notes) {
          if ('display_name' in d.notes.map_info) {
            return d.notes.map_info.display_name.split('\n').map(function(item, index) {
                 return {
                   text : item,
                   notes : d.notes,
                   index : index
                 }})
          }
        }
        // Must not have returned a display name, return the metabolite name
        // instead
        return [{text: d.name, notes: d.notes, index: 0}]; 
      })
      .enter()
      .append("tspan")
      .attr("class", "text")
      .text(d => d.text)
      .attr("dy", function(d) {
        if (d.index == 0) {
          return "0"
        } else {
          return "1.2em"
        }
      })
      .attr("x", function(d) {
        if ('align' in d.notes.map_info) {
          if (d.notes.map_info.align.indexOf("left") !== -1) {
            if ((d.notes.map_info.align.indexOf("upper") !== -1) || 
                (d.notes.map_info.align.indexOf("lower") !== -1)) {
              return '-.6em';
            }
            else {
              return '-.9em';
            }
          }
          else if (d.notes.map_info.align.indexOf("center") !== -1) {
            return '0em';
          }
          else {
            if ((d.notes.map_info.align.indexOf("upper") !== -1) ||
                (d.notes.map_info.align.indexOf("lower") !== -1)) {
              return '.6em';
            }
            else {
              return '.9em';
            }
          }
        }
        else {
          return '.9em';
        }
      });

    var updateNode = function() {
      this.attr("transform", function(d) {
        return "translate(" + Math.max(0, Math.min(width, d.x)) + ","
          + Math.max(0, Math.min(height, d.y)) + ")";
      });
    }

    var updateAnchorLink = function() {
      this.attr("x1", function(d) {
        return d.source.x;
      }).attr("y1", function(d) {
        return d.source.y;
      }).attr("x2", function(d) {
        return d.target.x;
      }).attr("y2", function(d) {
        return d.target.y;
      });
    }

    var updateLink = function() {
        try {
          this.attr("d", function(d) {
            return calculate_path(d, force, Math.max(this.getTotalLength(), 15));
          });
        }
        catch(err) {
          return '';
        }
    }

    var updateAnchorNodes = function() {
      this.each(function(d, i) {
        if(i % 2 == 0) {
          d.x = d.node.x;
          d.y = d.node.y;
        } else {
          var b = this.childNodes[1].getBBox();

          var diffX = d.x - d.node.x;
          var diffY = d.y - d.node.y;

          var dist = Math.sqrt(diffX * diffX + diffY * diffY);

          var shiftX = b.width * (diffX - dist) / (dist * 2);
          shiftX = Math.max(-b.width, Math.min(0, shiftX));
          var shiftY = 5;
          this.childNodes[1].setAttribute("transform", "translate(" + shiftX + "," + shiftY + ")");
        }
      });
    }

    force.on("tick", function() {
      link.call(updateLink);
      node.call(updateNode);
    });

    // flux_scale = d3.scale.pow().exponent(1/2)
    flux_scale = d3.scale.linear()
      .domain([d3.min(fluxes), d3.max(fluxes)])
      .range([1.5, 6]);

    // metabolite_scale = d3.scale.pow().exponent(1/2)
    metabolite_scale = d3.scale.linear()
      .domain([d3.min(mfluxes), d3.max(mfluxes)])
      .range([4, 8]);

    arrowhead_scale = d3.scale.linear()
      .domain([1.5, 6])
      .range([6, 12]);

    function get_flux_width (rxn) {
      try {
        var flux = flux_scale(Math.abs(rxn.notes.map_info.flux));
        if (!isNaN(flux)) {
          return flux;
        } else{
          return {{ default_flux_width }};
        }
      }
      catch(err) {
        return {{ default_flux_width }}; // Default linewidth
      }
    }

    function get_flux_dasharray (d) {
      try {
        if (d.rxn.notes.map_info.group == 'ko') {
          return "5, 5, 1, 5";
        }
        else if (Math.abs(d.rxn.notes.map_info.flux) < 1E-6) {
          return "5,5";
        }
      }
      catch(err) {
        return;
      }
    }

    function get_flux_stroke (d) {
      if ('color' in d.notes.map_info) {
        return d.notes.map_info.color;
      } else {
          return rxncolor(d.notes.map_info.group);
        }
    }

    function markerscale (d) {
      return arrowhead_scale(get_flux_width(d)) + "pt";
    }

    function get_node_radius (d) {
      if ('cofactor' in d) {return 4;}
      try {
        var nodewidth = metabolite_scale(Math.abs(d.notes.map_info.flux));
        if (!isNaN(nodewidth)) {
          return nodewidth;
        } else {
          return 5;
        }
      }
      catch(err){ return 5; }
    }



// **************************************************************
// **************************************************************
// Button Behavior

    // Node selection effect
    svg.selectAll("circle").on("mouseover", function(){
        d3.select(this)
        .style("fill", "red");
    })

  //   var focus_node = "null";
  //   svg.selectAll("circle").on("click", function(){
  //     if (focus_node == "null") {
  //       focus_node = d3.select(this);
  //       console.log(focus_node);
  //       d3.select(focus_node)
  //       .style("fill", "red");
  //     }
  //     else {
  //       d3.select(focus_node)
  //       .style("fill", function(d) { 
  //         if (d.type != 'rxn') {
  //           if ('color' in d.notes.map_info) {
  //             return d.notes.map_info.color;
  //           } else {
  //             return '#1f77b4';
  //           }
  //         } else return "";});

  //         // focus_node = d3.select(this);
  //         // d3.select(focus_node)
  //         // .style("fill", "red");
  //     }

  // })

    svg.selectAll("circle").on("mouseout", function(){
      d3.select(this)
      .style("fill", function(d) { 
        if (d.type != 'rxn') {
          if ('color' in d.notes.map_info) {
            return d.notes.map_info.color;
          } else {
            return '#1f77b4';
          }
        } else return "";});
  })


    // hari: !important
    svg.selectAll(".link")
      .attr("stroke-width", function (d) {return get_flux_width(d.rxn);})
      .attr("stroke", function (d) {return get_flux_stroke(d.rxn);})
      .attr("stroke-dasharray", get_flux_dasharray);

    svg.selectAll("marker")
      .attr("markerWidth", markerscale)
      .attr("markerHeight", markerscale)
      .select("path")
      .attr("fill", get_flux_stroke);

    //btn test
    // d3.select("#{{ figure_id }}_options .marker_button").on("click", function() {
    //   svg.selectAll("marker")
    //   .select("path")
    //   .transition()
    //   .style("fill", "purple");
    // });

    // Button: Show Reaction Node
    // Show/hide the reaction control node points.
    d3.select("#{{ figure_id }}_options .reactionbutton").on("click", function() {
      // _note: 把原来的HTML对象储存成jquery对象
      var $this = $(this);
      $this.toggleClass('btn-danger');
      $this.toggleClass('btn-on');
      d3.selectAll(".node.rxn")
        .classed("hidden", function (d, i) {
          return !d3.select(this).classed("hidden");
        });

      if($this.hasClass('btn-on')){
        $this.text('Hide Reaction Nodes');
      } else {
        $this.text('Show Reaction Nodes');
      }
    });

    // Button: Disable Path Color
    d3.select("#{{ figure_id }}_options .path_button").on("click", function() {
      var $this = $(this);
      $this.toggleClass('btn-danger');
      $this.toggleClass('btn-success');
      $this.toggleClass('btn-off');

        
      if($this.hasClass('btn-off')){
        $this.text('Show Path Color');

        svg.selectAll(".link")
        // color is not effective
        .transition()
        .style("stroke", "grey");
  
        svg.selectAll("marker")
        .select("path")
        .transition()
        .style("fill", "grey");
      } else {
        $this.text('Diasble Path Color');

        svg.selectAll(".link")
        // color is not effective
        .transition()
        .style("stroke", function (d) {return get_flux_stroke(d.rxn);});
  
        svg.selectAll("marker")
        .select("path")
        .transition()
        .style("fill", get_flux_stroke);
      }
    });

    d3.select("#{{ figure_id }}_options .reset_button").on("click", function() {
      svg.selectAll(".link")
      // color is not effective
      .transition()
      .style("stroke", function (d) {return get_flux_stroke(d.rxn);});

      svg.selectAll("marker")
      .select("path")
      .transition()
      .style("fill", get_flux_stroke);

      svg.selectAll("circle")
      .transition()
      .style("fill", function(d) { 
        if (d.type != 'rxn') {
          if ('color' in d.notes.map_info) {
            return d.notes.map_info.color;
          } else {
            return '#1f77b4';
          }
        } else return "";});

    });

    d3.select("#{{ figure_id }}_options .animate_button").on("click", function() {
      //svg.selectAll(".metabolite")
      graph = new Graph();
      // add unhidden metabolites

      // nodes.forEach(function(metabolite) {
      //   //graph.vertices.addVertex(metabolite);
      //   console.log(metabolite.id);
      //   graph.addVertex(metabolite.id);
      // });

      bilinks.forEach(function(link, i) {
        //console.log(link.source.id, " -> ",link.target.id);
        // if (!link.source.id in graph.getVertives) {
        //   graph.addVertex(link.source.id);
        // }

        // _debug: can't use id cause id will be identical
        //console.log(link.source.id, " -> ",link.target.id);

        // Ignore cofacor nodes
        if(link.target.cofactor) {
          return;
        }
        //tar = link.target.id;
       // tar.pointed_edge = 
        graph.addVertex(link.source.id);
        graph.addVertex(link.target.id);
        graph.addEdge(link.source.id, link.target.id);

        if(link.rxn.notes["map_info"]["reversibility"] == true){
          console.log("reverse!")
          graph.addEdge(link.target.id, link.source.id);
        }
        // svg.select("#" + link.id)
        // .transition()
        // .duration(700)
        // .delay( i * 700)
        // .style("stroke", "#006633");

      });
      
      console.log(graph.toString());
      var count = 0;
      function printNode(value) {
        
        console.log('Visited vertex: ' + value);
        count++;
        svg.select("circle#" + "_" + value)
        .transition()
        .duration(700)
        .delay(count* 700)
        .style("fill", "red");
      }

      var select = d3.select("#info").property("value");
      graph.dfs(select, printNode);
    });


d3.select("#{{ figure_id }}_options .test_button").on("click", function () {
  d3.select("#info")
  .property("value", "test");
  graph = new Graph();
  var myVertices = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'];
  for (var i = 0; i < myVertices.length; i++) {
    graph.addVertex(myVertices[i]);
  }
  graph.addEdge('A', 'B');
  graph.addEdge('A', 'C');
  graph.addEdge('A', 'D');
  graph.addEdge('C', 'D');
  graph.addEdge('C', 'G');
  graph.addEdge('D', 'G');
  graph.addEdge('D', 'H');
  graph.addEdge('B', 'E');
  graph.addEdge('B', 'F');
  graph.addEdge('E', 'I');
  console.log(graph.toString());

  function printNode(value) {
    console.log('Visited vertex: ' + value);
  }
  graph.dfs("B", printNode);

});


    svg.selectAll(".metabolite")
      .attr("r", get_node_radius);

    d3.select("#{{ figure_id }}_options .download")
      .on("click", function () {

        // Add position data to model nodes
        force.nodes().forEach(function (node) {
          if (node.fixed) {
            if (node.type == "rxn") {
              // Reaction object
              obj = $.grep(model.reactions, function(e){ return e.id == node.id; })[0];
              if (!("notes" in obj)) { obj.notes = {}; }
              if (!("map_info" in obj.notes)) { obj.notes.map_info = {}; }
              obj.notes.map_info['x'] = node.x;
              obj.notes.map_info['y'] = node.y;
            } else {
              // Look in metabolites
              if (!('cofactor' in node)) {
                obj = $.grep(model.metabolites, function(e){ return e.id == node.id; })[0];
                if (!("notes" in obj)) { obj.notes = {}; }
                if (!("map_info" in obj.notes)) { obj.notes.map_info = {}; }
                obj.notes.map_info['x'] = node.x;
                obj.notes.map_info['y'] = node.y;
              } else {
                rxn = $.grep(model.reactions, function(e){ 
                  return e.id == node.cofactor; })[0];
                rxn.notes.map_info.cofactors[node.notes.orig_id]['x'] = node.x
                rxn.notes.map_info.cofactors[node.notes.orig_id]['y'] = node.y
              }
            }
          }
        });

        var json = JSON.stringify(model);
        var blob = new Blob([json], {type: "application/json"});
        saveAs(blob, model.id + ".json");
      });
  }

  main({{ figure_id }}model);


  

});


class Queue {
  constructor() {
    var items = [];
    this.enqueue = function (element) {
      items.push(element);
    };
    this.dequeue = function () {
      return items.shift();
    };
    this.front = function () {
      return items[0];
    };
    this.isEmpty = function () {
      return items.length == 0;
    };
    this.clear = function () {
      items = [];
    };
    this.size = function () {
      return items.length;
    };
    this.print = function () {
      console.log(items.toString());
    };
  }
}

// Graph function
class Graph {
  constructor() {
    var vertices = []; //存储图中所有的顶点名字
    var adjList = new Dictionary(); //用字典来存储邻接表
    this.addVertex = function (v) {
      // Ignore existed vertex.
      if (vertices.indexOf(v) in vertices) {
        return;
      }
      vertices.push(v);
      adjList.set(v, []); //顶点为键，字典值为空数组
    };
    this.addEdge = function (v, w) {
      adjList.get(v).push(w); //基于有向图
      //adjList.get(w).push(v); //基于无向图
    };
    this.hasVertex = function (v) {
      return v in vertices;
    }
    this.toString = function () {
      var s = '';
      for (var i = 0; i < vertices.length; i++) {
        s += vertices[i] + ' -> ';
        var neighbors = adjList.get(vertices[i]);
        for (var j = 0; j < neighbors.length; j++) {
          s += neighbors[j] + ' ';
        }
        s += '\n';
      }
      return s;
    };
    var initializeColor = function () {
      var color = [];
      for (var i = 0; i < vertices.length; i++) {
        color[vertices[i]] = 'white';
      }
      return color;
    };

    

    this.dfs2 = function (s, callback) {
      var color = initializeColor(); //前面的颜色数组
      // for (var i=0; i<vertices.length; i++){
      //     if (color[vertices[i]] === 'white'){
      //         dfsVisit(vertices[i], color, callback); //递归调用未被访问过的顶点
      //     }
      // }
      if (color[s] == "white") {
        dfsVisit2(s, color, callback);
      }
    };
    var dfsVisit2 = function (u, color, callback) {
      color[u] = 'grey';
      if (callback) {
        callback(u);
      }
      var neighbors = adjList.get(u); //邻接表


      for (var i = 0; i < neighbors.length; i++) {
        var w = neighbors[i];
        // Stop recursion when end vertex is visted.
        if (neighbors.length == 0)
        {
          color[u] = 'black';
          callback(u);
          return;
        }

        if (color[w] === 'white') {
          dfsVisit2(w, color, callback); //添加顶点w入栈
        }

      }
      color[u] = 'black';
    };


    this.dfs = function (s, callback) {
      var color = initializeColor(); //前面的颜色数组
      // for (var i=0; i<vertices.length; i++){
      //     if (color[vertices[i]] === 'white'){
      //         dfsVisit(vertices[i], color, callback); //递归调用未被访问过的顶点
      //     }
      // }
      if (color[s] == "white") {
        dfsVisit(s, color, callback);
      }
    };
    var dfsVisit = function (u, color, callback) {
      color[u] = 'grey';
      if (callback) {
        callback(u);
      }
      var neighbors = adjList.get(u); //邻接表
      for (var i = 0; i < neighbors.length; i++) {
        var w = neighbors[i];
        if (color[w] === 'white') {
          dfsVisit(w, color, callback); //添加顶点w入栈
        }
      }
      color[u] = 'black';
    };

    this.bfs = function (v, callback) {
      var color = initializeColor(),
        queue = new Queue(); //创建一个队列
      queue.enqueue(v); //入队列
      while (!queue.isEmpty()) {
        var u = queue.dequeue(), //出队列
          neighbors = adjList.get(u); //邻接表
        color[u] = 'grey'; //发现了但还未完成对其的搜素
        for (var i = 0; i < neighbors.length; i++) {
          var w = neighbors[i]; //顶点名
          if (color[w] === 'white') {
            color[w] = 'grey'; //发现了它
            queue.enqueue(w); //入队列循环
          }
        }
        color[u] = 'black'; //已搜索过
        if (callback) {
          callback(u);
        }
      }
    };

  }
}

// Class Dictionary
class Dictionary {
  constructor() {
    var items = {};
    this.set = function (key, value) {
      items[key] = value;
    };
    this.remove = function (key) {
      if (this.has(key)) {
        delete items[key];
        return true;
      }
      return false;
    };
    this.has = function (key) {
      return items.hasOwnProperty(key);
    };
    this.get = function (key) {
      return this.has(key) ? items[key] : undefined;
    };
    this.clear = function () {
      items = {};
    };
    this.size = function () {
      return Object.keys(items).length;
    };
    this.keys = function () {
      return Object.keys(items);
    };
    this.values = function () {
      var values = [];
      for (var k in items) {
        if (this.has(k)) {
          values.push(items[k]);
        }
      }
      return values;
    };
    this.each = function (fn) {
      for (var k in items) {
        if (this.has(k)) {
          fn(k, items[k]);
        }
      }
    };
    this.getItems = function () {
      return items;
    };
  }
}












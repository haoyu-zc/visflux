<!DOCTYPE html> <html> <head>         <title>Test d3flux page</title>         <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.2/require.min.js" integrity="sha256-Vjusm6Kh2U7/tb6jBh+MOfxnaf2TWsTph34bMKhC1Qc=" crossorigin="anonymous"></script>         <script src="https://code.jquery.com/jquery-3.1.1.min.js" integrity="sha256-hVVnYaiADRTO2PzUGmuLJr8BLUSjGIZsDYGmIJLv2b8=" crossorigin="anonymous"></script>         <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">         </head> <body><div class="container-fluid">
  <div class="navbar navbar-inverse navbar-static-top" role="navigation">
    <div class="container">
      <div class="navbar-header">
        <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target=".navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
        <a class="navbar-brand" href="/">
          <i class="fa fa-comments-o"></i>
          VisMap
        </a>
      </div>
      <div class="navbar-collapse collapse">
        <ul class="nav navbar-nav">
          <li><a href="/">Home</a></li>
        </ul>
        <ul class="nav navbar-nav">
          <li><a href="/">Document</a></li>
        </ul>
        <ul class="nav navbar-nav navbar-right">
          <li><a href="/login">Login</a></li>
        </ul>
      </div>
    </div>
  </div>
</div>

<div class="container">
  <div class="row row-offcanvas row-offcanvas-right">



    <div class="row">
      <!-- <div class="col-xs-12 col-sm-9"> -->
      <div class="col-md-10">
        <div id="d3flux001">
          
        </div>
      </div>

      <!-- <div id="d3flux001_options" class="col-xs-6 col-sm-3 sidebar-offcanvas"> -->
      <div id="d3flux001_options" class="col-md-2">

        <div class="btn-group-vertical" role="group" aria-label="btn-group-vertical">
          <h4>Output</h4>
          <button type="button" class="download btn btn-primary ">Save JSON</button>
          <button type="button" class="svgbutton btn btn-info ">Download SVG</button>

          <h4>Traverse</h4>
          <input type="text" class="form-control" id="info" placeholder="Node info" type="text" value="">
          <div class="checkbox">
            <label>
              <input type="checkbox" value="">
              Reversibility
            </label>
          </div>
          <div class="checkbox">
            <label>
              <input type="checkbox" value="">
              Enable Animation
            </label>
          </div>
          <button type="button" class="animate_button btn btn-warning ">Downstream Nodes</button>

          <h4>Search</h4>
          <input type="text" class="form-control" id="search" placeholder="Name or id" type="text" value="">
          <button type="button" class="test_button btn btn-danger ">Search Node</button>

          <h4>Custom</h4>
          <button type="button" class="reactionbutton btn btn-success ">Show Reaction Nodes</button>
          <!-- feat:(点击后切换路径及箭头颜色，按钮颜色同时变化成相同颜色) -->
          <button type="button" class="path_button btn btn-warning ">Path Color</button>
          <!-- <button type="button" class="marker_button btn btn-warning ">Select Marker</button> -->
          <button type="button" class="reset_button btn btn-warning ">Reset</button>
          <button id="zoom_in" type="button" class="zoom_button btn">Zoom in</button>
          <button id="zoom_out" type="button" class="zoom_button btn  ">Zoom out</button>
          <!-- <button type="button" class="test_button btn btn-test ">Alg Test</button> -->
          <div class="checkbox">
            <label>
              <input id="cb-zoom" type="checkbox" value="">
              Disable mouse zoom
            </label>
          </div>
          <div class="checkbox">
            <label>
              <input id="cb-tip" type="checkbox" value="">
              Disable hover tip
            </label>
          </div>


        </div>
      </div>
      <!--/.sidebar-offcanvas-->
    </div> <!-- row -->

    <!-- <div class="col-xs-6 col-sm-3 sidebar-offcanvas" id="sidebar">
        <div class="list-group">
          <li class="list-group-item active">External Links</li>
          <a href="http://bigg.ucsd.edu/" target="_blank" class="list-group-item">BiGG</a>
          <a href="https://opencobra.github.io/" target="_blank" class="list-group-item">Open Cobra</a>
          <a href="https://d3js.org/" target="_blank" class="list-group-item">D3.js</a>
          <a href="#" class="list-group-item">...</a>
          <a href="#" class="list-group-item">...</a>
          <a href="#" class="list-group-item">...</a>
          <a href="#" class="list-group-item">...</a>
          <a href="#" class="list-group-item">...</a>
          <a href="https://getbootstrap.com/" target="_blank" class="list-group-item">Bootstrap</a>
        </div>
      </div> -->
    <!--.sidebar-offcanvas-->

  </div>
</div>

<script type="text/Javascript">
var d3flux001model = {"metabolites": [{"id": "atp_c", "name": "ATP", "compartment": "", "formula": "C10H16N5O13P3", "notes": {"map_info": {"hidden": true, "color": "#FFD700", "display_name": "ATP"}}}, {"id": "agluc_c", "name": "alpha-D-Glucose", "compartment": "", "formula": "C6H12O6", "notes": {"map_info": {"display_name": "AGLUC", "x": 562.387621812248, "y": 295.17930885274376}}}, {"id": "adp_c", "name": "ADP", "compartment": "", "formula": "C10H15N5O10P2", "notes": {"map_info": {"hidden": true, "color": "#b5cf6b", "display_name": "ADP"}}}, {"id": "ag6p_c", "name": "alpha-D-Glucose 6-phosphate", "compartment": "", "formula": "C6H13O9P", "notes": {"map_info": {"display_name": "AG6P", "x": 400.15821897333734, "y": 393.71342156823033}}}, {"id": "bgluc_c", "name": "beta-D-Glucose", "compartment": "", "formula": "C6H12O6", "notes": {"map_info": {"display_name": "BGLUC", "x": 650.1590863527327, "y": 346.0933149283232}}}, {"id": "bg6p_c", "name": "beta-D-Glucose 6-phosphate", "compartment": "", "formula": "C6H13O9P", "notes": {"map_info": {"display_name": "BG6P", "x": 555.8397258305718, "y": 382.4548178458906}}}, {"id": "bf6p_c", "name": "beta-D-Fructose 6-phosphate", "compartment": "", "formula": "C6H13O9P", "notes": {"map_info": {"display_name": "BF6P", "x": 490.015263949736, "y": 478.96632683882035}}}, {"id": "bfbp_c", "name": "beta-D-Fructose 1,6-bisphosphate", "compartment": "", "formula": "C6H14O12P2", "notes": {"map_info": {"display_name": "BFBP", "x": 581.2441388658821, "y": 428.2301909422422}}}, {"id": "h2o_c", "name": "H2O", "compartment": "", "formula": "H2O", "notes": {"map_info": {"hidden": true, "color": "#87CEFA", "display_name": "H2O"}}}, {"id": "h3po4_c", "name": "Orthophosphate", "compartment": "", "formula": "H3PO4", "notes": {"map_info": {"display_name": "H3PO4", "x": 376.0377608585718, "y": 299.115936280925}}}, {"id": "dhap_c", "name": "Glycerone phosphate", "compartment": "", "formula": "C3H7O6P", "notes": {"map_info": {"display_name": "DHAP", "x": 664.8301564507927, "y": 450.0815282647398}}}, {"id": "g3p_c", "name": "D-Glyceraldehyde 3-phosphate", "compartment": "", "formula": "C3H7O6P", "notes": {"map_info": {"display_name": "G3P", "x": 642.2480084999771, "y": 531.1113849925381}}}, {"id": "g1p_c", "name": "D-Glucose 1-phosphate", "compartment": "", "formula": "C6H13O9P", "notes": {"map_info": {"display_name": "G1P", "x": 276.3609386953701, "y": 299.49530723825956}}}, {"id": "cellb_c", "name": "Cellobiose", "compartment": "", "formula": "C12H22O11", "notes": {"map_info": {"display_name": "CELLB", "x": 85.49332297069017, "y": 68.44751023423629}}}, {"id": "gluc_c", "name": "D-Glucose", "compartment": "", "formula": "C6H12O6", "notes": {"map_info": {"display_name": "GLUC", "x": 219.86107428867035, "y": 121.70035295058608}}}, {"id": "glucoside_c", "name": "beta-D-Glucoside", "compartment": "", "formula": "C6H11O6R", "notes": {"map_info": {"display_name": "GLUCOSIDE", "x": 7.226882607725685, "y": 119.87769490849897}}}, {"id": "roh_c", "name": "ROH", "compartment": "", "formula": "HOR", "notes": {"map_info": {"display_name": "ROH", "x": 37.2457471345794, "y": 193.72729744603586}}}, {"id": "cellodex_c", "name": "Cellodextrin", "compartment": "", "formula": "H2O(C6H10O5)n", "notes": {"map_info": {"display_name": "CELLODEX", "x": 111.52008548856577, "y": 11.884109269879211}}}, {"id": "sucrose_c", "name": "Sucrose", "compartment": "", "formula": "C12H22O11", "notes": {"map_info": {"display_name": "SUCROSE", "x": 133.82429370786966, "y": 233.06551629744183}}}, {"id": "fruc_c", "name": "D-Fructose", "compartment": "", "formula": "C6H12O6", "notes": {"map_info": {"display_name": "FRUC", "x": 46.9307744782529, "y": 231.18711800081542}}}, {"id": "g6p_c", "name": "D-Glucose 6-phosphate", "compartment": "", "formula": "C6H13O9P", "notes": {"map_info": {"display_name": "G6P"}}}, {"id": "f6p_c", "name": "D-Fructose 6-phosphate", "compartment": "", "formula": "C6H13O9P", "notes": {"map_info": {"display_name": "F6P", "x": 69.58800544372133, "y": 321.84025640000164}}}, {"id": "utp_c", "name": "Uridine 5'-triphosphate", "compartment": "", "formula": "C9H15N2O15P3", "notes": {"map_info": {"display_name": "UTP", "x": 231.78662748996481, "y": 337.8236303243125}}}, {"id": "ppi_c", "name": "Diphosphate", "compartment": "", "formula": "H4P2O7", "notes": {"map_info": {"display_name": "PPI", "x": 322.2012590258715, "y": 393.4252791157189}}}, {"id": "udpg_c", "name": "UDP-glucose", "compartment": "", "formula": "C15H22N2O17P2", "notes": {"map_info": {"display_name": "UDPG", "x": 615.0286720425372, "y": 236.2166804588889}}}, {"id": "ump_c", "name": "UMP", "compartment": "", "formula": "C9H13N2O9P", "notes": {"map_info": {"display_name": "UMP", "x": 407.0561616494576, "y": 195.03644490439765}}}, {"id": "starch_c", "name": "Starch", "compartment": "", "formula": "(C12H20O10)n", "notes": {"map_info": {"display_name": "STARCH", "x": 371.9088621917777, "y": 134.41938300058305}}}, {"id": "amylose_c", "name": "Amylose", "compartment": "", "formula": "(C6H10O5)n", "notes": {"map_info": {"display_name": "AMYLOSE", "x": 285.4338973997374, "y": 166.48761994110075}}}, {"id": "udp_c", "name": "UDP", "compartment": "", "formula": "C9H14N2O12P2", "notes": {"map_info": {"display_name": "UDP", "x": 536.5738020628746, "y": 203.83240893757966}}}, {"id": "aat6p_c", "name": "alpha,alpha'-Trehalose 6-phosphate", "compartment": "", "formula": "C12H23O14P", "notes": {"map_info": {"display_name": "AAT6P", "x": 459.5947583208847, "y": 269.83235450287935}}}, {"id": "dextrin_c", "name": "Dextrin", "compartment": "", "formula": "(C12H20O10)n", "notes": {"map_info": {"display_name": "DEXTRIN", "x": 365.40065169440686, "y": 59.301210813696756}}}, {"id": "maltose_c", "name": "Maltose", "compartment": "", "formula": "C12H22O11", "notes": {"map_info": {"display_name": "MALTOSE", "x": 279.1900819655812, "y": 102.73661265990195}}}, {"id": "maltodex_c", "name": "Maltodextrin", "compartment": "", "formula": "H2O(C6H10O5)n", "notes": {"map_info": {"display_name": "MALTODEX", "x": 262.06593525525665, "y": 17.936632072656202}}}, {"id": "trehalose_c", "name": "alpha,alpha-Trehalose", "compartment": "", "formula": "C12H22O11", "notes": {"map_info": {"display_name": "TREHALOSE", "x": 296.1820219595426, "y": 228.72189542970446}}}, {"id": "e4p_c", "name": "D-Erythrose 4-phosphate", "compartment": "", "formula": "C4H9O7P", "notes": {"map_info": {"display_name": "E4P", "x": 482.1563010938804, "y": 619.3729383540534}}}, {"id": "xyl5p_c", "name": "D-Xylulose 5-phosphate", "compartment": "", "formula": "C5H11O8P", "notes": {"map_info": {"display_name": "XYL5P", "x": 580.0959770475629, "y": 630.1225188050767}}}, {"id": "s7p_c", "name": "Sedoheptulose 7-phosphate", "compartment": "", "formula": "C7H15O10P", "notes": {"map_info": {"display_name": "S7P", "x": 741.4215126196317, "y": 611.1569245105139}}}, {"id": "r5p_c", "name": "D-Ribose 5-phosphate", "compartment": "", "formula": "C5H11O8P", "notes": {"map_info": {"display_name": "R5P"}}}, {"id": "ribul5p_c", "name": "D-Ribulose 5-phosphate", "compartment": "", "formula": "C5H11O8P", "notes": {"map_info": {"display_name": "RIBUL5P", "x": 692.2779829476408, "y": 677.5801464681745}}}, {"id": "dr5p_c", "name": "2-Deoxy-D-ribose 5-phosphate", "compartment": "", "formula": "C5H11O7P", "notes": {"map_info": {"display_name": "DR5P"}}}, {"id": "adh_c", "name": "Acetaldehyde", "compartment": "", "formula": "C2H4O", "notes": {"map_info": {"display_name": "ADH", "x": 687.7381302057066, "y": 562.6414269703606}}}, {"id": "dor_c", "name": "Deoxyribose", "compartment": "", "formula": "C5H10O4", "notes": {"map_info": {"display_name": "DOR", "x": 757.769177875819, "y": 419.1089832026941}}}, {"id": "dr1p_c", "name": "2-Deoxy-D-ribose 1-phosphate", "compartment": "", "formula": "C5H11O7P", "notes": {"map_info": {"display_name": "DR1P"}}}, {"id": "amp_c", "name": "AMP", "compartment": "", "formula": "C10H14N5O7P", "notes": {"map_info": {"hidden": true, "color": "#b5cf6b", "display_name": "AMP"}}}, {"id": "prpp_c", "name": "5-Phospho-alpha-D-ribose 1-diphosphate", "compartment": "", "formula": "C5H13O14P3", "notes": {"map_info": {"display_name": "PRPP", "x": 559.4500246855185, "y": 823.9320071414921}}}, {"id": "ribose_c", "name": "D-Ribose", "compartment": "", "formula": "C5H10O5", "notes": {"map_info": {"display_name": "RIBOSE"}}}, {"id": "r1p_c", "name": "alpha-D-Ribose 1-phosphate", "compartment": "", "formula": "C5H11O8P", "notes": {"map_info": {"display_name": "R1P", "x": 530.014618783235, "y": 670.9374539075925}}}, {"id": "6pdg_c", "name": "6-Phospho-D-gluconate", "compartment": "", "formula": "C6H13O10P", "notes": {"map_info": {"display_name": "6PDG", "x": 782.9759769036705, "y": 756.7535666659547}}}, {"id": "nadp_c", "name": "NADP", "compartment": "", "formula": "C21H29N7O17P3", "notes": {"map_info": {"hidden": true, "color": "#b5cf6b", "display_name": "NADP"}}}, {"id": "co2_c", "name": "CO2", "compartment": "", "formula": "CO2", "notes": {"map_info": {"hidden": true, "color": "#87CEFA", "display_name": "CO2"}}}, {"id": "nadph_c", "name": "NADPH", "compartment": "", "formula": "C21H30N7O17P3", "notes": {"map_info": {"display_name": "NADPH", "x": 811.9794018703574, "y": 669.3019504481477}}}, {"id": "h_c", "name": "H+", "compartment": "", "formula": "H", "notes": {"map_info": {"hidden": true, "color": "#87CEFA", "display_name": "H"}}}, {"id": "6pgdl_c", "name": "D-Glucono-1,5-lactone 6-phosphate", "compartment": "", "formula": "C6H11O9P", "notes": {"map_info": {"display_name": "6PGDL", "x": 724.9655641828559, "y": 859.7346874574941}}}, {"id": "gla_c", "name": "D-Gluconic acid", "compartment": "", "formula": "C6H12O7", "notes": {"map_info": {"display_name": "GLA"}}}, {"id": "m6p_c", "name": "D-Mannose 6-phosphate", "compartment": "", "formula": "C6H13O9P", "notes": {"map_info": {"display_name": "M6P", "x": 341.96438455286824, "y": 509.47603331986556}}}, {"id": "agal_c", "name": "alpha-D-Galactose", "compartment": "", "formula": "C6H12O6", "notes": {"map_info": {"display_name": "AGAL", "x": 735.524250703799, "y": 32.8106553154858}}}, {"id": "gal6p_c", "name": "alpha-D-Galactose 1-phosphate", "compartment": "", "formula": "C6H13O9P", "notes": {"map_info": {"display_name": "GAL6P", "x": 576.4873388248716, "y": 32.73278703949063}}}, {"id": "udpgal_c", "name": "UDP-alpha-D-galactose", "compartment": "", "formula": "C15H24N2O17P2", "notes": {"map_info": {"display_name": "UDPGAL", "x": 730.8009813451288, "y": 140.35802320081993}}}, {"id": "man_c", "name": "D-Mannose", "compartment": "", "formula": "C6H12O6", "notes": {"map_info": {"display_name": "MAN", "x": 306.99795330130786, "y": 585.7044065173892}}}, {"id": "m1p_c", "name": "D-Mannose 1-phosphate", "compartment": "", "formula": "C6H13O9P", "notes": {"map_info": {"display_name": "M1P", "x": 246.86517230074475, "y": 504.20724602249834}}}, {"id": "gtp_c", "name": "GTP", "compartment": "", "formula": "C10H16N5O14P3", "notes": {"map_info": {"display_name": "GTP", "x": 148.53589257138202, "y": 505.0179136617162}}}, {"id": "gdpman_c", "name": "GDP-mannose", "compartment": "", "formula": "C16H25N5O16P2", "notes": {"map_info": {"display_name": "GDPMAN", "x": 190.86378124423413, "y": 383.883705258427}}}, {"id": "bfruc_c", "name": "beta-D-Fructose", "compartment": "", "formula": "C6H12O6", "notes": {"map_info": {"display_name": "BFRUC", "x": 341.01536802986243, "y": 416.1515017783988}}}, {"id": "glc_c", "name": "D-Glucosamine", "compartment": "", "formula": "C6H13NO5", "notes": {"map_info": {"display_name": "GLC", "x": 227.35574072150445, "y": 672.9299516242157}}}, {"id": "glc6p_c", "name": "D-Glucosamine 6-phosphate", "compartment": "", "formula": "C6H14NO8P", "notes": {"map_info": {"display_name": "GLC6P", "x": 389.71944681795526, "y": 564.9532438837804}}}, {"id": "glu_c", "name": "L-Glutamine", "compartment": "", "formula": "C5H10N2O3", "notes": {"map_info": {"display_name": "GLU", "x": 475.9105785931074, "y": 659.7558814064492}}}, {"id": "glu__l_c", "name": "L-Glutamate", "compartment": "", "formula": "C5H9NO4", "notes": {"map_info": {"display_name": "GLU", "x": 363.3904612857043, "y": 625.8587669454257}}}, {"id": "nh3_c", "name": "Ammonia", "compartment": "", "formula": "NH3", "notes": {"map_info": {"display_name": "NH3", "x": 470.9511509310192, "y": 558.1336300206311}}}], "reactions": [{"id": "R01786", "name": "", "metabolites": {"adp_c": 1, "ag6p_c": 1, "agluc_c": -1, "atp_c": -1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {"atp_c": {"x": 543.7851499897051, "y": 339.0162322179188}}, "group": 1, "reversibility": false, "x": 451.64025222930576, "y": 331.62985291577706}}}, {"id": "R01602", "name": "", "metabolites": {"agluc_c": -1, "bgluc_c": 1}, "lower_bound": -1000, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {}, "group": 1, "reversibility": true, "x": 637.5116029748984, "y": 312.1449908631645}}}, {"id": "R01600", "name": "", "metabolites": {"adp_c": 1, "atp_c": -1, "bg6p_c": 1, "bgluc_c": -1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {"atp_c": {"x": 691.282057938204, "y": 372.7867477639131}}, "group": 1, "reversibility": false, "x": 629.2795181529568, "y": 376.8560756353217}}}, {"id": "R03321", "name": "", "metabolites": {"bf6p_c": 1, "bg6p_c": -1}, "lower_bound": -1000, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {}, "group": 1, "reversibility": true, "x": 532.3219522465469, "y": 443.81897513263965}}}, {"id": "R02740", "name": "", "metabolites": {"ag6p_c": -1, "bf6p_c": 1}, "lower_bound": -1000, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {}, "group": 1, "reversibility": true, "x": 453.45037906337666, "y": 421.03686350623065}}}, {"id": "R02739", "name": "", "metabolites": {"ag6p_c": -1, "bg6p_c": 1}, "lower_bound": -1000, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {}, "group": 1, "reversibility": true, "x": 490.60738636722937, "y": 363.45058637906476}}}, {"id": "R04780", "name": "", "metabolites": {"bf6p_c": 1, "bfbp_c": -1, "h2o_c": -1, "h3po4_c": 1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {"h2o_c": {"x": 635.5220902737983, "y": 403.80942418763584}}, "group": 1, "reversibility": false, "x": 527.7737742474792, "y": 407.0095925633973}}}, {"id": "R01070", "name": "", "metabolites": {"bfbp_c": -1, "dhap_c": 1, "g3p_c": 1}, "lower_bound": -1000, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {}, "group": 1, "reversibility": true, "x": 588.9044045694097, "y": 475.6276102575332}}}, {"id": "R01015", "name": "", "metabolites": {"dhap_c": 1, "g3p_c": -1}, "lower_bound": -1000, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {}, "group": 1, "reversibility": true, "x": 679.0267416122066, "y": 488.433704927066}}}, {"id": "R00959", "name": "", "metabolites": {"ag6p_c": 1, "g1p_c": -1}, "lower_bound": -1000, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {}, "group": 1, "reversibility": true}}}, {"id": "R00306", "name": "", "metabolites": {"cellb_c": -1, "gluc_c": 2, "h2o_c": -1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {"h2o_c": {"x": 58.80440444884778, "y": 102.41444192352556}}, "group": 2, "reversibility": false}}}, {"id": "R03527", "name": "", "metabolites": {"gluc_c": 1, "glucoside_c": -1, "h2o_c": -1, "roh_c": 1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {"h2o_c": {"x": 14.380509654859225, "y": 160.08244883643061}}, "group": 2, "reversibility": false, "x": 68.4187409052557, "y": 153.8394200157294}}}, {"id": "R02887", "name": "", "metabolites": {"cellb_c": 1, "cellodex_c": -1, "gluc_c": 1, "h2o_c": -1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {"h2o_c": {"x": 164.40890322886045, "y": 32.922660378310304}}, "group": 2, "reversibility": false, "x": 132.03908260581468, "y": 40.63478038969565}}}, {"id": "R00801", "name": "", "metabolites": {"fruc_c": 1, "gluc_c": 1, "h2o_c": -1, "sucrose_c": -1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {"h2o_c": {"x": 145.49965963606166, "y": 193.94758503935032}}, "group": 2, "reversibility": false, "x": 111.33951280445586, "y": 205.9003491739277}}}, {"id": "R08639", "name": "", "metabolites": {"g1p_c": -1, "g6p_c": 1}, "lower_bound": -1000, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {}, "group": 2, "reversibility": true, "x": 216.30724327775818, "y": 286.52715879421413}}}, {"id": "R00771", "name": "", "metabolites": {"f6p_c": 1, "g6p_c": -1}, "lower_bound": -1000, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {}, "group": 2, "reversibility": true, "x": 141.94585941371892, "y": 331.23162734600373}}}, {"id": "R00760", "name": "", "metabolites": {"adp_c": 1, "atp_c": -1, "f6p_c": 1, "fruc_c": -1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {"atp_c": {"x": 8.531696474163269, "y": 252.34417121296968}}, "group": 2, "reversibility": false, "x": 43.112519431533244, "y": 284.90531143834437}}}, {"id": "R00299", "name": "", "metabolites": {"adp_c": 1, "atp_c": -1, "g6p_c": 1, "gluc_c": -1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {"atp_c": {"x": 215.14029357357904, "y": 182.4220543915163}}, "group": 2, "reversibility": false}}}, {"id": "R00289", "name": "", "metabolites": {"g1p_c": -1, "ppi_c": 1, "udpg_c": 1, "utp_c": -1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {}, "group": 2, "reversibility": false, "x": 318.0874791385593, "y": 338.49579938363235}}}, {"id": "R11308", "name": "", "metabolites": {"cellb_c": 1, "cellodex_c": -1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {}, "group": 2, "reversibility": false, "x": 79.95946984073989, "y": 26.313483095415933}}}, {"id": "R00287", "name": "", "metabolites": {"g1p_c": 1, "h2o_c": -1, "udpg_c": -1, "ump_c": 1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {"h2o_c": {"x": 499.7460881226107, "y": 186.85573798630014}}, "group": 2, "reversibility": false, "x": 439.9521438990816, "y": 225.85924158653756}}}, {"id": "R02111", "name": "", "metabolites": {"amylose_c": 1, "g1p_c": 1, "h3po4_c": -1, "starch_c": -1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {}, "group": 2, "reversibility": false, "x": 337.43201845427916, "y": 208.5512916665505}}}, {"id": "R00292", "name": "", "metabolites": {"udp_c": 1, "udpg_c": -1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {}, "group": 2, "reversibility": false, "x": 578.7657734400814, "y": 187.30514252139562}}}, {"id": "R02737", "name": "", "metabolites": {"aat6p_c": 1, "ag6p_c": -1, "udp_c": 1, "udpg_c": -1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {}, "group": 2, "reversibility": false, "x": 535.6981647477769, "y": 262.3425247928432}}}, {"id": "R02110", "name": "", "metabolites": {"amylose_c": -1, "starch_c": 1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {}, "group": 2, "reversibility": false, "x": 317.95953933769, "y": 128.58330747629734}}}, {"id": "R02112", "name": "", "metabolites": {"dextrin_c": 1, "maltose_c": 1, "starch_c": -1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {}, "group": 2, "reversibility": false, "x": 347.76183202879906, "y": 103.02449458707675}}}, {"id": "R11262", "name": "", "metabolites": {"h2o_c": -1, "maltodex_c": -1, "maltose_c": 1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {"h2o_c": {"x": 334.6495131382789, "y": 37.369958315389994}}, "group": 2, "reversibility": false, "x": 294.8407542213006, "y": 56.05769695703591}}}, {"id": "R01790", "name": "", "metabolites": {"gluc_c": 1, "h2o_c": -1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {"h2o_c": {}}, "group": 2, "reversibility": false, "hidden": true}}}, {"id": "R01791", "name": "", "metabolites": {"gluc_c": 1, "h2o_c": -1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {"h2o_c": {}}, "group": 2, "reversibility": false, "hidden": true}}}, {"id": "R00028", "name": "", "metabolites": {"gluc_c": 2, "h2o_c": -1, "maltose_c": -1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {"h2o_c": {"x": 254.7535108685688, "y": 66.26912202804259}}, "group": 2, "reversibility": false, "x": 246.48830441565062, "y": 88.16378272704814}}}, {"id": "R05196", "name": "", "metabolites": {"amylose_c": -1, "gluc_c": -1, "maltose_c": 1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {}, "group": 2, "reversibility": false, "x": 271.80615973027375, "y": 137.0173709258125}}}, {"id": "R02778", "name": "", "metabolites": {"aat6p_c": -1, "h2o_c": -1, "h3po4_c": 1, "trehalose_c": 1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {"h2o_c": {"x": 422.009999191393, "y": 242.78220774584048}}, "group": 2, "reversibility": false, "x": 399.4240761701047, "y": 256.44752726139194}}}, {"id": "R00010", "name": "", "metabolites": {"gluc_c": 2, "h2o_c": -1, "trehalose_c": -1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {"h2o_c": {"x": 246.58551669422113, "y": 245.65225975199596}}, "group": 2, "reversibility": false, "x": 264.2695543994098, "y": 190.9540930350304}}}, {"id": "R01830", "name": "", "metabolites": {"bf6p_c": -1, "e4p_c": 1, "g3p_c": -1, "xyl5p_c": 1}, "lower_bound": -1000, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {}, "group": 3, "reversibility": true, "x": 558.5498152494528, "y": 565.4519374063406}}}, {"id": "R01641", "name": "", "metabolites": {"g3p_c": -1, "r5p_c": 1, "s7p_c": -1, "xyl5p_c": 1}, "lower_bound": -1000, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {}, "group": 3, "reversibility": true, "x": 645.5576791217956, "y": 623.0217466849278}}}, {"id": "R01827", "name": "", "metabolites": {"bf6p_c": 1, "e4p_c": 1, "g3p_c": -1, "s7p_c": -1}, "lower_bound": -1000, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {}, "group": 3, "reversibility": true}}}, {"id": "R01529", "name": "", "metabolites": {"ribul5p_c": -1, "xyl5p_c": 1}, "lower_bound": -1000, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {}, "group": 3, "reversibility": true, "x": 648.431796853175, "y": 670.0603304362822}}}, {"id": "R01066", "name": "", "metabolites": {"adh_c": 1, "dr5p_c": -1, "g3p_c": 1}, "lower_bound": -1000, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {}, "group": 3, "reversibility": true}}}, {"id": "R02750", "name": "", "metabolites": {"adp_c": -1, "atp_c": 1, "dor_c": 1, "dr5p_c": -1}, "lower_bound": -1000, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {"atp_c": {"x": 805.58977999561, "y": 438.80261047148025}}, "group": 3, "reversibility": true, "x": 773.1845843509695, "y": 473.3760206972427}}}, {"id": "R02749", "name": "", "metabolites": {"dr1p_c": -1, "dr5p_c": 1}, "lower_bound": -1000, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {}, "group": 3, "reversibility": true, "x": 793.1125242767549, "y": 536.4387865042139}}}, {"id": "R01056", "name": "", "metabolites": {"r5p_c": -1, "ribul5p_c": 1}, "lower_bound": -1000, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {}, "group": 3, "reversibility": true}}}, {"id": "R01049", "name": "", "metabolites": {"amp_c": 1, "atp_c": -1, "prpp_c": 1, "r5p_c": -1}, "lower_bound": -1000, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {"atp_c": {"x": 519.1207058161426, "y": 707.7533846772403}, "amp_c": {"x": 496.46279444725917, "y": 824.3710550033867}}, "group": 3, "reversibility": true}}}, {"id": "R01051", "name": "", "metabolites": {"adp_c": 1, "atp_c": -1, "r5p_c": 1, "ribose_c": -1}, "lower_bound": -1000, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {"atp_c": {"x": 646.3014688075784, "y": 742.9744516466404}}, "group": 3, "reversibility": true}}}, {"id": "R01057", "name": "", "metabolites": {"r1p_c": -1, "r5p_c": 1}, "lower_bound": -1000, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {}, "group": 3, "reversibility": true}}}, {"id": "R01528", "name": "", "metabolites": {"6pdg_c": -1, "co2_c": 1, "h_c": 1, "nadp_c": -1, "nadph_c": 1, "ribul5p_c": 1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {"nadp_c": {"x": 728.6877671917019, "y": 760.0651292308745}, "co2_c": {"x": 785.0844362380909, "y": 711.47393945432}, "h_c": {"x": 707.5826739737444, "y": 723.1342174074431}}, "group": 3, "reversibility": false}}}, {"id": "R02035", "name": "", "metabolites": {"6pdg_c": 1, "6pgdl_c": -1, "h2o_c": -1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {"h2o_c": {"x": 676.5267200633143, "y": 825.750733472178}}, "group": 3, "reversibility": false}}}, {"id": "R01737", "name": "", "metabolites": {"6pdg_c": 1, "adp_c": 1, "atp_c": -1, "gla_c": -1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {"atp_c": {}}, "group": 3, "reversibility": false}}}, {"id": "R01819", "name": "", "metabolites": {"bf6p_c": 1, "m6p_c": -1}, "lower_bound": -1000, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {}, "group": 4, "reversibility": true, "x": 407.77180794410265, "y": 488.7217967471254}}}, {"id": "R01092", "name": "", "metabolites": {"adp_c": 1, "agal_c": -1, "atp_c": -1, "gal6p_c": 1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {"atp_c": {"x": 683.5539608088324, "y": 43.641039999212936}}, "group": 4, "reversibility": false, "x": 661.1257997163924, "y": 10.144174210922777}}}, {"id": "R00955", "name": "", "metabolites": {"g1p_c": 1, "gal6p_c": -1, "udpg_c": -1, "udpgal_c": 1}, "lower_bound": -1000, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {}, "group": 4, "reversibility": true, "x": 499.912875670499, "y": 83.2116596303837}}}, {"id": "R00291", "name": "", "metabolites": {"udpg_c": -1, "udpgal_c": 1}, "lower_bound": -1000, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {}, "group": 4, "reversibility": true, "x": 649.1123352229595, "y": 178.78291684439546}}}, {"id": "R01326", "name": "", "metabolites": {"adp_c": 1, "atp_c": -1, "m6p_c": 1, "man_c": -1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {"atp_c": {"x": 258.4230267965711, "y": 587.3591401000807}}, "group": 4, "reversibility": false}}}, {"id": "R01818", "name": "", "metabolites": {"m1p_c": 1, "m6p_c": -1}, "lower_bound": -1000, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {}, "group": 4, "reversibility": true, "x": 282.27695263279355, "y": 521.3026857381224}}}, {"id": "R00885", "name": "", "metabolites": {"gdpman_c": 1, "gtp_c": -1, "m1p_c": -1, "ppi_c": 1}, "lower_bound": -1000, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {}, "group": 4, "reversibility": true, "x": 220.06876812952896, "y": 451.2953449668551}}}, {"id": "R03920", "name": "", "metabolites": {"adp_c": 1, "atp_c": -1, "bf6p_c": 1, "bfruc_c": -1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {"atp_c": {"x": 326.552925743654, "y": 451.1335557827706}}, "group": 4, "reversibility": false, "x": 403.4626763422727, "y": 443.16503638951}}}, {"id": "R01961", "name": "", "metabolites": {"adp_c": 1, "atp_c": -1, "glc6p_c": 1, "glc_c": -1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {"atp_c": {"x": 194.68316866173126, "y": 622.9246212690017}}, "group": 4, "reversibility": false, "x": 304.9501003883288, "y": 637.6305105731036}}}, {"id": "R00768", "name": "", "metabolites": {"bf6p_c": -1, "glc6p_c": 1, "glu__l_c": 1, "glu_c": -1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {}, "group": 4, "reversibility": false, "x": 435.240492330163, "y": 608.8323829108688}}}, {"id": "R00765", "name": "", "metabolites": {"bf6p_c": 1, "glc6p_c": -1, "h2o_c": -1, "nh3_c": 1}, "lower_bound": 0, "upper_bound": 1000, "gene_reaction_rule": "", "notes": {"map_info": {"cofactors": {"h2o_c": {"x": 388.33172034658014, "y": 517.8389034455512}}, "group": 4, "reversibility": false, "x": 431.0012954655306, "y": 532.3475893196554}}}], "genes": [], "id": "AP_v2", "compartments": {"": ""}, "notes": {"map_info": {}}};

require.config({
  paths: {
    d3: "https://d3js.org/d3.v3.min",
    cola: "http://marvl.infotech.monash.edu/webcola/cola.v3.min",
    math: "https://cdnjs.cloudflare.com/ajax/libs/mathjs/2.4.0/math.min",
    FileSaver: "https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2014-11-29/FileSaver.min",

  },
  shim: {
    'cola': {
      exports: 'cola'
    }
  }
});

require(["cola", "d3", "math", "FileSaver", ], function (cola, d3, math, FileSaver) {

  function main(model) {
    // Render a metabolic network representation of a cobra.Model object.
    //
    // `model` is a json-serialized representation of a metabolic network,
    // generated by cobra.display.flux_analysis.create_model_json

    // Height and width of the SVG figure, passed via jinja2
    var width = 1280,
    height = 1024;

    // var color = d3.scale.category10();

    // Reaction color allows different reaction groups to be colored
    // accordingly. Grouping is mainly handled by color_redox_reactions. First
    // group ('undefined') is for normal reactions (gray). Second group is for
    // knocked-out reactions, (red). Others are rendered in different
    // contrasting colors
    var rxncolor = d3.scale.ordinal()
      // .range(["#bbb", "#d62728", "#ff7f0e", "#2ca02c", "#9467bd",
      //         "#8c564b", "#e377c2", "#7f7f7f", "#bcbd22", "#17becf"])
      .range(["#bbb", "#d62728",
        "#eb6a9b",
        "#6f3589",
        "#f18572",
        "#246035",
        "#009fea",
        "#83522b",
        "#29378a",
        "#989033"])
      .domain([undefined, 'ko', 1, 2, 3, 4, 5, 6, 7, 8]);

    // Initialize the d3 force diagram. Parameters like charge, gavity, and
    // link distance are currently hard-coded in -- probably should change
    // this?
    var force = cola.d3adaptor()
      .linkDistance(30)
      
      .size([width, height]);
    // var force = d3.layout.force()
    //   .linkDistance(30)
    //   .charge(-100)
    //   .chargeDistance(400)
    //   .gravity(.015)
    //   .size([width, height]);

    // Allow for a background SVG template if one has been provided, otherwise
    // initalize the svg canvas
    if (true) {
      var svg = d3.select("#d3flux001").append("svg")
        .attr("viewBox", "0 0 1280 1024")
        .attr("style", "display:block;margin:auto;width:100%");
    } else {
      var svg = d3.select("#d3flux001").select("svg");
    }

    // Append the CSS styles
    svg.append("style").text('.node.rxn{fill:#ffa319}.node.rxn.hidden{fill:none;stroke:none;stroke-width:0}.link{fill:none;stroke-linecap:round}text.nodelabel{font-size:12pt;fill:#555;font-family:Arial}text.nodelabel.cofactor{font-size:9.600000000000001pt;fill:#789}text.nodelabel.rxn{fill:#a9a9a9;font-size:9.600000000000001pt;font-style:italic}marker.inactive,.node.inactive,text.inactive{fill-opacity:.5}.link.inactive{stroke-opacity:.5}.d3-tip{line-height:1;font-weight:bold;padding:12px;background:rgba(0,0,0,0.8);color:#fff;border-radius:2px}.d3-tip:after{box-sizing:border-box;display:inline;font-size:10px;width:100%;line-height:1;color:rgba(0,0,0,0.8);position:absolute;text-align:center}.d3-tip.n:after{margin:-1px 0 0 0;top:100%;left:0}svg{z-index:5}');

    // Zoom function
    
    svg_panel = d3.select("#svg_panel");
    var zoom = d3.behavior.zoom().scaleExtent([0.5, 4]).on("zoom", zoomed);
    function zoomed() {
      svg.attr("transform",
          "translate(" + zoom.translate() + ")" +
          "scale(" + zoom.scale() + ")"
      );
    }
  
    function interpolateZoom (translate, scale) {
        var self = this;
        return d3.transition().duration(350).tween("zoom", function () {
            var iTranslate = d3.interpolate(zoom.translate(), translate),
                iScale = d3.interpolate(zoom.scale(), scale);
            return function (t) {
                zoom
                    .scale(iScale(t))
                    .translate(iTranslate(t));
                zoomed();
            };
        });
    }

    function zoomClick() {
      var clicked = d3.event.target,
          direction = 1,
          factor = 0.2,
          target_zoom = 1,
          center = [width / 2, height / 2],
          extent = zoom.scaleExtent(),
          translate = zoom.translate(),
          translate0 = [],
          l = [],
          view = {x: translate[0], y: translate[1], k: zoom.scale()};
  
      d3.event.preventDefault();
      direction = (this.id === 'zoom_in') ? 1 : -1;
      target_zoom = zoom.scale() * (1 + factor * direction);
  
      if (target_zoom < extent[0] || target_zoom > extent[1]) { return false; }
  
      translate0 = [(center[0] - view.x) / view.k, (center[1] - view.y) / view.k];
      view.k = target_zoom;
      l = [translate0[0] * view.k + view.x, translate0[1] * view.k + view.y];
  
      view.x += center[0] - l[0];
      view.y += center[1] - l[1];
  
      interpolateZoom([view.x, view.y], view.k);
  }
  

  var zoomEnabled = false;
  var zoomToggle = d3.select('#cb-zoom').on('click', toggleZoom);
  toggleZoom();

  function toggleZoom() {
    zoomEnabled = !zoomEnabled;
    if (zoomEnabled) {
      svg.call(zoom);
    } else {
      svg.on('.zoom', null);
    }
  };

                        
  d3.selectAll('.zoom_button').on('click', zoomClick);

  // svg.call(zoom);


    // Code for the figure manipulation buttons.
    d3.select("#d3flux001_options .reactionbutton").on("click", function() {
      // Show/hide the reaction control node points.
      // _note: 把原来的HTML对象储存成jquery对象
      var $this = $(this);
      $this.toggleClass('btn-danger');
      d3.selectAll(".node.rxn")
        .classed("hidden", function (d, i) {
          return !d3.select(this).classed("hidden");
        });
      if($this.hasClass('btn-danger')){
        $this.text('Hide Reaction Nodes');
      } else {
        $this.text('Show Reaction Nodes');
      }
    });

    d3.select("#d3flux001_options .svgbutton").on("click", function() { 
      // Download the svg using SVG Crowbar. This is still very buggy.

      var e = document.createElement('script'); 
      e.setAttribute('src', 'https://rawgit.com/pstjohn/svg-crowbar/gh-pages/svg-crowbar.js'); 
      e.setAttribute('class', 'svg-crowbar'); 
      document.body.appendChild(e); 
    });

    function calc_imag_angle(x1, y1, x2, y2) {
      // Function to calculate the imaginary angle of the line between two
      // points. Used to find the average direction to the metabolites of a
      // reaction node
      var calcAngleVal = Math.atan2(x1-x2,y1-y2);
      return math.exp(math.multiply(math.i, calcAngleVal));
    }

    function average_angles(rxn, rstoich, nodes) {
      // Find the slope of the line through the reaction node as a function of
      // the current position of the metabolites. Reactants and products are
      // separated and placed on opposite ends of the nodes.
      //
      // Looks like for cofactors, rstoich could be set to zero to remove the
      // effect on the reaction slope. 
      var angles = []
      for (var n in rstoich) {
        if (!('cofactor' in nodes[n])) {
          var angle = calc_imag_angle(rxn.x, rxn.y, nodes[n].x, nodes[n].y);
          angles.push([math.multiply(angle, rstoich[n])]);
        }
      }
      return math.mean(angles).toPolar().phi;
    }

    function average_dist(rxn, rstoich, nodes) {
      // Calculate the average distance to the reaction nodes, which is used to
      var dist = []
      for (var n in rstoich) {
        var this_dist = math.sqrt(math.square(rxn.x - nodes[n].x) 
            + math.square(rxn.y - nodes[n].y));
        dist.push([this_dist]);
      }
      return math.mean(dist);
    }

    function calculate_path(d, force) {
      var s = d.source,
      t = d.target,
      r = d.rxn,
      a=.1, b=.1,
      cp_inv = {};

      var angle = average_angles(r, d.rstoich, force.nodes());
      var dist = average_dist(r, d.rstoich, force.nodes());

      cp = new Point2D(r.x - math.multiply(.5*dist, math.sin(angle)),
                 r.y - math.multiply(.5*dist, math.cos(angle)));

      cp_inv = new Point2D(r.x + math.multiply(.5*dist, math.sin(angle)),
                     r.y + math.multiply(.5*dist, math.cos(angle)));

      s_point = new Point2D(s.x, s.y)
      r_point = new Point2D(r.x, r.y)
      t_point = new Point2D(t.x, t.y)

      var padding = 5;
      // var total_len = quadraticBezierLength(s, cp, r) + quadraticBezierLength(r, cp_inv, t);


      // Adjust control points to start late and stop early
      if (plot_reverse_arrowhead(d.rxn)) {

        first_intersect = Intersection.intersectBezier2Circle(
    s_point, cp, r_point, s_point, 
    padding + arrowhead_scale(get_flux_width(d.rxn)) + get_node_radius(s)).slice(0)[0];
        last_intersect = Intersection.intersectBezier2Circle(
    r_point, cp_inv, t_point, t_point, 
    padding + arrowhead_scale(get_flux_width(d.rxn)) + get_node_radius(t)).slice(-1)[0];
        a = first_intersect;
        b = last_intersect;

      }
      else {

        first_intersect = Intersection.intersectBezier2Circle(
    s_point, cp, r_point, s_point, padding + get_node_radius(s)).slice(0)[0];
        last_intersect = Intersection.intersectBezier2Circle(
    r_point, cp_inv, t_point, t_point,
    padding + arrowhead_scale(get_flux_width(d.rxn)) + get_node_radius(t)).slice(-1)[0];
        a = first_intersect;
        b = last_intersect;

        // b = 1 - (padding + arrowhead_scale(get_flux_width(d.rxn)))/total_len;
      }
            
      var source_x = s.x*a**2 - 2*s.x*a + s.x - 2*cp.x*a**2 + 2*cp.x*a + r.x*a**2;
      var source_y = s.y*a**2 - 2*s.y*a + s.y - 2*cp.y*a**2 + 2*cp.y*a + r.y*a**2;

      var cp_x = -cp.x*a + cp.x + r.x*a;
      var cp_y = -cp.y*a + cp.y + r.y*a;

      var cp_inv_x = -r.x*b + r.x + cp_inv.x*b
      var cp_inv_y = -r.y*b + r.y + cp_inv.y*b

      var target_x = r.x*b**2 - 2*r.x*b + r.x - 2*cp_inv.x*b**2 + 2*cp_inv.x*b + t.x*b**2;
      var target_y = r.y*b**2 - 2*r.y*b + r.y - 2*cp_inv.y*b**2 + 2*cp_inv.y*b + t.y*b**2;

      if ( isFinite(source_x) & isFinite(cp_x) & isFinite(cp_inv_x) & isFinite(target_x) ) {
        return "M" + source_x + "," + source_y
          + " Q" + cp_x + "," + cp_y
          + " " + r.x + "," + r.y
          + " Q" + cp_inv_x + "," + cp_inv_y
          +" " + target_x + "," + target_y;
      } else {
        return "M" + s.x + "," + s.y
          + " L" + r.x + "," + r.y
          +" L" + t.x + "," + t.y;
      }
    }


// d3.tip
// Copyright (c) 2013 Justin Palmer
//
// Tooltips for d3.js SVG visualizations

// Public - contructs a new tooltip
//
// Returns a tip
d3.tip = function() {
  var direction = d3_tip_direction,
      offset    = d3_tip_offset,
      html      = d3_tip_html,
      node      = initNode(),
      svg       = null,
      point     = null,
      target    = null

  function tip(vis) {
    svg = getSVGNode(vis)
    point = svg.createSVGPoint()
    document.body.appendChild(node)
  }

  // Public - show the tooltip on the screen
  //
  // Returns a tip
  tip.show = function() {
    var args = Array.prototype.slice.call(arguments)
    if(args[args.length - 1] instanceof SVGElement) target = args.pop()

    var content = html.apply(this, args),
        poffset = offset.apply(this, args),
        dir     = direction.apply(this, args),
        nodel   = d3.select(node), i = 0,
        coords

    nodel.html(content)
      .style({ opacity: 1, 'pointer-events': 'all' })

    while(i--) nodel.classed(directions[i], false)
    coords = direction_callbacks.get(dir).apply(this)
    nodel.classed(dir, true).style({
      top: (coords.top +  poffset[0]) + 'px',
      left: (coords.left + poffset[1]) + 'px'
    })

    return tip
  }

  // Public - hide the tooltip
  //
  // Returns a tip
  tip.hide = function() {
    nodel = d3.select(node)
    nodel.style({ opacity: 0, 'pointer-events': 'none' })
    return tip
  }

  // Public: Proxy attr calls to the d3 tip container.  Sets or gets attribute value.
  //
  // n - name of the attribute
  // v - value of the attribute
  //
  // Returns tip or attribute value
  tip.attr = function(n, v) {
    if (arguments.length < 2 && typeof n === 'string') {
      return d3.select(node).attr(n)
    } else {
      var args =  Array.prototype.slice.call(arguments)
      d3.selection.prototype.attr.apply(d3.select(node), args)
    }

    return tip
  }

  // Public: Proxy style calls to the d3 tip container.  Sets or gets a style value.
  //
  // n - name of the property
  // v - value of the property
  //
  // Returns tip or style property value
  tip.style = function(n, v) {
    if (arguments.length < 2 && typeof n === 'string') {
      return d3.select(node).style(n)
    } else {
      var args =  Array.prototype.slice.call(arguments)
      d3.selection.prototype.style.apply(d3.select(node), args)
    }

    return tip
  }

  // Public: Set or get the direction of the tooltip
  //
  // v - One of n(north), s(south), e(east), or w(west), nw(northwest),
  //     sw(southwest), ne(northeast) or se(southeast)
  //
  // Returns tip or direction
  tip.direction = function(v) {
    if (!arguments.length) return direction
    direction = v == null ? v : d3.functor(v)

    return tip
  }

  // Public: Sets or gets the offset of the tip
  //
  // v - Array of [x, y] offset
  //
  // Returns offset or
  tip.offset = function(v) {
    if (!arguments.length) return offset
    offset = v == null ? v : d3.functor(v)

    return tip
  }

  // Public: sets or gets the html value of the tooltip
  //
  // v - String value of the tip
  //
  // Returns html value or tip
  tip.html = function(v) {
    if (!arguments.length) return html
    html = v == null ? v : d3.functor(v)

    return tip
  }

  function d3_tip_direction() { return 'n' }
  function d3_tip_offset() { return [0, 0] }
  function d3_tip_html() { return ' ' }

  var direction_callbacks = d3.map({
    n:  direction_n,
    s:  direction_s,
    e:  direction_e,
    w:  direction_w,
    nw: direction_nw,
    ne: direction_ne,
    sw: direction_sw,
    se: direction_se
  }),

  directions = direction_callbacks.keys()

  function direction_n() {
    var bbox = getScreenBBox()
    return {
      top:  bbox.n.y - node.offsetHeight,
      left: bbox.n.x - node.offsetWidth / 2
    }
  }

  function direction_s() {
    var bbox = getScreenBBox()
    return {
      top:  bbox.s.y,
      left: bbox.s.x - node.offsetWidth / 2
    }
  }

  function direction_e() {
    var bbox = getScreenBBox()
    return {
      top:  bbox.e.y - node.offsetHeight / 2,
      left: bbox.e.x
    }
  }

  function direction_w() {
    var bbox = getScreenBBox()
    return {
      top:  bbox.w.y - node.offsetHeight / 2,
      left: bbox.w.x - node.offsetWidth
    }
  }

  function direction_nw() {
    var bbox = getScreenBBox()
    return {
      top:  bbox.nw.y - node.offsetHeight,
      left: bbox.nw.x - node.offsetWidth
    }
  }

  function direction_ne() {
    var bbox = getScreenBBox()
    return {
      top:  bbox.ne.y - node.offsetHeight,
      left: bbox.ne.x
    }
  }

  function direction_sw() {
    var bbox = getScreenBBox()
    return {
      top:  bbox.sw.y,
      left: bbox.sw.x - node.offsetWidth
    }
  }

  function direction_se() {
    var bbox = getScreenBBox()
    return {
      top:  bbox.se.y,
      left: bbox.e.x
    }
  }

  function initNode() {
    var node = d3.select(document.createElement('div'))
    node.style({
      position: 'absolute',
      opacity: 0,
      pointerEvents: 'none',
      boxSizing: 'border-box'
    })

    return node.node()
  }

  function getSVGNode(el) {
    el = el.node()
    if(el.tagName.toLowerCase() == 'svg')
      return el

    return el.ownerSVGElement
  }

  // Private - gets the screen coordinates of a shape
  //
  // Given a shape on the screen, will return an SVGPoint for the directions
  // n(north), s(south), e(east), w(west), ne(northeast), se(southeast), nw(northwest),
  // sw(southwest).
  //
  //    +-+-+
  //    |   |
  //    +   +
  //    |   |
  //    +-+-+
  //
  // Returns an Object {n, s, e, w, nw, sw, ne, se}
  function getScreenBBox() {
    var targetel   = target || d3.event.target,
        bbox       = {},
        matrix     = targetel.getScreenCTM(),
        tbbox      = targetel.getBBox(),
        width      = tbbox.width,
        height     = tbbox.height,
        x          = tbbox.x,
        y          = tbbox.y,
        scrollTop  = document.documentElement.scrollTop || document.body.scrollTop,
        scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft


    point.x = x + scrollLeft
    point.y = y + scrollTop
    bbox.nw = point.matrixTransform(matrix)
    point.x += width
    bbox.ne = point.matrixTransform(matrix)
    point.y += height
    bbox.se = point.matrixTransform(matrix)
    point.x -= width
    bbox.sw = point.matrixTransform(matrix)
    point.y -= height / 2
    bbox.w  = point.matrixTransform(matrix)
    point.x += width
    bbox.e = point.matrixTransform(matrix)
    point.x -= width / 2
    point.y -= height / 2
    bbox.n = point.matrixTransform(matrix)
    point.y += height
    bbox.s = point.matrixTransform(matrix)

    return bbox
  }

  return tip
};



    // _note: return a boolean of whether to draw reverse arrowhead
    function plot_reverse_arrowhead(rxn) {
     return (((Math.abs(rxn.notes.map_info.flux) < 1E-8) || isNaN(rxn.notes.map_info.flux))
      && rxn.notes.map_info.reversibility);
    }

    // _note: need to distinguish links and bilinks
    // _ans: links include the edge between a source node and a reaction node.
    metabolites = jQuery.extend(true, [], model.metabolites),
    reactions = jQuery.extend(true, [], model.reactions),
    nodes = [],
    node_lookup = {},
    links = [],
    mlinks = [],
    bilinks = []
    rxn_stoich = {};

    var mfluxes = [];
    metabolites.forEach(function(metabolite) {
      if ('notes' in metabolite) {
        if ('map_info' in metabolite.notes) {
          if (metabolite.notes.map_info.hidden) {
            return;
          } else {
            if (false && (Math.abs(metabolite.notes.map_info.flux) < 1E-6)) {
              return;
            }
            mfluxes.push(Math.abs(metabolite.notes.map_info.flux));
          }
        }
      }
      // It's not hidden, add it to the nodes
      metabolite.type = "metabolite";
      nodes.push(metabolite);
    });

    // Create a dictionary-like structure to allow us to look up nodes by their
    // id, rather than numerical index
    for (var i = 0, len = nodes.length; i < len; i++) {
      var node = nodes[i]
      node_lookup[node.id] = i;
    }

    // Handle cofactor metabolites
    reactions.forEach(function(reaction) {
      if ('notes' in reaction) {
        if ('map_info' in reaction.notes) {
          if ('hidden' in reaction.notes.map_info) {
            if (reaction.notes.map_info.hidden) {
              return;
            }
          }
          if (false &&
              (Math.abs(reaction.notes.map_info.flux) < 1E-6)) {
            return;
          } 
          if ('cofactors' in reaction.notes.map_info) {
            for (var cofactor in reaction.notes.map_info.cofactors) {

              var orig_metabolite = obj = $.grep(model.metabolites,
                  function(e){ return e.id == cofactor; })[0];
              var cf_id = cofactor + '_' + reaction.id;

              var cofactor_node = {
                'id' : cf_id,
                'name' : orig_metabolite.name,
                'type' : "cofactor",
                'notes' : {
                  'map_info' : reaction.notes.map_info.cofactors[cofactor],
                  'orig_id' : cofactor
                },
                'cofactor' : reaction.id
              };

              if ('flux' in orig_metabolite.notes.map_info) {
                cofactor_node.notes.map_info['flux'] = orig_metabolite.notes.map_info.flux;
              }

              // Inheret color from original metabolite
              if ('color' in orig_metabolite.notes.map_info) {
                cofactor_node.notes.map_info.color = 
                  orig_metabolite.notes.map_info.color;
              }

              // Get the cofactor display name from the original 
              // metabolite node
              if ('map_info' in orig_metabolite.notes) {
                if (('display_name' in orig_metabolite.notes.map_info) &
	            !('display_name' in cofactor_node.notes.map_info)) {
                  cofactor_node.notes.map_info.display_name =
                    orig_metabolite.notes.map_info.display_name;
                }
              }

              reaction.metabolites[cf_id] = reaction.metabolites[cofactor];
              delete reaction.metabolites[cofactor];

              // Update nodes and node_lookup table
              nodes.push(cofactor_node);
              node_lookup[cf_id]  = nodes.length - 1;

            }
          }
        }
      }
    });


    // Create a dictionary-like structure to allow us to look up nodes by their
    // id, rather than numerical index
    // for (var i = 0, len = nodes.length; i < len; i++) {
    //   var node = nodes[i]
    //   node_lookup[node.id] = i;
    // }

    var fluxes = [];
    reactions.forEach(function(reaction) {

      // Don't add hidden reactions
      if ('notes' in reaction) {
        if ('map_info' in reaction.notes) {
          if (reaction.notes.map_info.hidden) {
            return;
          } else if ('flux' in reaction.notes.map_info) {
            if (false && (Math.abs(reaction.notes.map_info.flux) < 1E-6)) {
              return;
            }
            fluxes.push(Math.abs(reaction.notes.map_info.flux));
            if (reaction.notes.map_info.flux < -1E-10) {
              // If the reaction is flowing in reverse, switch products and
              // reactants.
              for (var item in reaction.metabolites) {
                reaction.metabolites[item] *= -1;
              }
            }
          }
        }
      }

      // !important
      reaction['reactants'] = []
      reaction['products'] = []

      for (var item in reaction.metabolites) {
        if (reaction.metabolites[item] > 0) {
          if (item in node_lookup) {
            // _notes: reaction.metabolites[item] = 1 -> product, = -1 -> reactant
            // Only add if the node hasn't been hidden
            reaction.products.push(item);
          }
        } else if (item in node_lookup) {
          reaction.reactants.push(item);
        }
      }

      var r_length = reaction.reactants.length,
      p_length = reaction.products.length,
      r_node = {
        "id" : reaction.id,
        "type" : "rxn"
      };

      // Add notes to reaction, if it exists (for map_info)
      if ("notes" in reaction) {
        r_node["notes"] = reaction.notes;
      }

      // Don't add links on the boundary
      if (r_length == 0 || p_length == 0) {
        return; 
      }

      // Add reaction to the nodes list, get the current length of the nodes
      // list as the reaction index for later.
      nodes.push(r_node);
      rindex = nodes.length - 1;


      // !important: drawing
      if (r_length >= p_length) {
        reaction.reactants.forEach(function (reactant, i) {
          // Add source -> rxn -> product triplets for drawing the line. For
          // each reactant (product), just get any product (reactant), as the
          // lines will overlap)
          mlinks.push({
            "source" : node_lookup[reactant],
            // _note: ? i % p_length - 1 ？
            "target" : node_lookup[reaction.products[i % p_length]],
            "rxn" : rindex
        });
      });
      } // else: products > reactants
      else {
        reaction.products.forEach(function (product, i) {
          mlinks.push({
            "source" : node_lookup[reaction.reactants[i % r_length]],
            "target" : node_lookup[product],
            "rxn" : rindex
          });
        });
      }

    });

    // Build the reaction stoichiometry database to remember which nodes are
    // reactants and which are products. Used to calculate path angles.
    // _note: rxn_stoich is the database.
    mlinks.forEach(function(link) {
      if (link.rxn in rxn_stoich) {
        rxn_stoich[link.rxn][link.source] = 1;
        rxn_stoich[link.rxn][link.target] = -1;
      } else {
        rxn_stoich[link.rxn] = {};
        rxn_stoich[link.rxn][link.source] = 1;
        rxn_stoich[link.rxn][link.target] = -1;
      }
    });

    mlinks.forEach(function(link, i) {
      var s = nodes[link.source],
      t = nodes[link.target],
      r = nodes[link.rxn];

      // _note: push 2 objects into links
      links.push({source: s, target: r}, {source: r, target: t});
      //_note: bilinks stand for what?
      bilinks.push({
        "source" : s,
        "target" : t,
        "rxn" : r,
        "rstoich" : rxn_stoich[link.rxn],
        "id": "bilink_" + i
      });
    });

    nodes.forEach( function (node) {
      if ("notes" in node) {
        if ("map_info" in node.notes) {
          if (("x" in node.notes.map_info) && ("y" in node.notes.map_info)) {
            node.x = node.notes.map_info.x;
            node.y = node.notes.map_info.y;
            node.fixed = 1;
          }
        }
      }
    });



    // Modify link strength based on flux:
    // link_strength_scale = d3.scale.pow().exponent(1/2)
    // link_strength_scale = d3.scale.linear()
    //   .domain([d3.min(fluxes), d3.max(fluxes)])
    //   .range([.2, 2]);
    //
    // force
    //   .linkStrength(function (link) {
    //     try {
    //       return link.rxn.notes.map_info.flux;
    //     }
    //     catch(err) {
    //       return 1;
    //     }
    //   });

    force
      .nodes(nodes)
      .links(links)
      .start();

    svg.append("defs").selectAll("marker")
      .data(reactions)
      .enter()
      .append("marker")
      .attr("id", function (d) { return "d3flux001" + d.id; })
      .attr("viewBox", "0 0 10 10")
      .attr("refX", 1)
      .attr("refY", 5)
      .attr("markerUnits", "userSpaceOnUse")
      .attr("markerWidth", "7pt")
      .attr("markerHeight", "7pt")
      .attr("orient", "auto")
      .attr("class", function (d) {
        var labels = "endmarker"
        if ('flux' in d.notes.map_info) {
          // _note: flux = 0 means this reaction is inactive
          if (d.notes.map_info.flux == 0) {
            labels = labels.concat(" inactive");
          }
        }
        return labels;
      })
      .append("path")
      .attr("d", "M 0 0 L 10 5 L 0 10 z");

    svg.append("defs").selectAll("marker")
      .data(reactions)
      .enter()
      .append("marker")
      .attr("id", function (d) { return "d3flux001" + d.id + "_rev"; })
      .attr("viewBox", "0 0 10 10")
      .attr("refX", 9)
      .attr("refY", 5)
      .attr("markerUnits", "userSpaceOnUse")
      .attr("markerWidth", "7pt")
      .attr("markerHeight", "7pt")
      .attr("orient", "auto")
      .attr("class", function (d) {
        var labels = "startmarker"
        if ('flux' in d.notes.map_info) {
          if (d.notes.map_info.flux == 0) {
            labels = labels.concat(" inactive");
          }
        }
        return labels;
      })
      .append("path")
      .attr("d", "M 10,10 0,5 10,0 Z");

    var link = svg.append('g').selectAll(".link")
      .data(bilinks)
      .enter()
      .append("path")
      .attr("class", function (d) {
        var labels = "link d3flux001" + d.rxn.id;
        if ('flux' in d.rxn.notes.map_info) {
          if (d.rxn.notes.map_info.flux == 0) {
            // _note: use labels to select the link.
            labels = labels.concat(" inactive");
          }
        }
        return labels;
      })
      .attr("id", function (d) {
        return d.id;
      })
      .attr("marker-end", function(d) {
        return "url(#d3flux001" + d.rxn.id + ")"; 
      })
      .attr("marker-start", function(d) {
  // Only show the reversible arrow if the reaction isnt carrying flux in
  // a particular direction
        if (plot_reverse_arrowhead(d.rxn)) {
    return "url(#d3flux001" + d.rxn.id + "_rev)";
  }
      });



    var node_drag = force.drag()
      .on("dragstart", dragstart);

    function dragstart(d) {
      d3.select(this).classed("fixed", d.fixed = true);
    }

    function releasenode(d) {
      // of course set the node to fixed so the force doesn't include the node in
      // its auto positioning stuff
      d.fixed = false; 
      force.resume();
    }

    function showInfo(d) {
      return d.id;
    }



// Node hover tooltip
var tip = d3.tip()
  .attr('class', 'd3-tip')
  .offset([10, 0])
  .direction('s')
  .html(function (d) {
    if (d.type == "metabolite") {
      return "<strong>Metabolite:</strong> <span style='color:red'>" + d.id + "</span>" + "<br/><br/>" +
      "<strong>Name:</strong> <span style='color:red'>" + d.name + "</span>" + "<br/><br/>" +
      "<strong>Formula:</strong> <span style='color:red'>" + d.formula + "</span>" + "<br/><br/>" +
      "<strong>Charge:</strong> <span style='color:red'>" + d.charge + "</span>";
    } else
    if (d.type == "rxn") {
      return "<strong>Reaction:</strong> <span style='color:red'>" + d.id + "</span>" + "<br/><br/>" +
      "<strong>Enzymes:</strong> <span style='color:red'>" + d.notes.Enzymes + "</span>" + "<br/><br/>" +
      "<strong>KEGG:</strong> <span style='color:red'>" + d.notes.KEGG + "</span>" + "<br/><br/>" +
      "<strong>MetaCyc:</strong> <span style='color:red'>" + d.notes.MetaCyc + "</span>" + "<br/><br/>" +
      "<strong>original_bigg_id:</strong> <span style='color:red'>" + d.notes.original_bigg_id + "</span>";
    } else
    if (d.type == "cofactor") {
      return "<strong>Cofactor:</strong> <span style='color:red'>" + d.id + "</span>" + "<br/><br/>" +
      "<strong>Name:</strong> <span style='color:red'>" + d.name + "</span>";
    }

    return "<strong>Node:</strong> <span style='color:red'>" + d.id + "</span>";
  })

  // Enable or disable tooltip
  var tipEnalbed;
  var tipToggle = d3.select('#cb-tip').on('click', toggleTip);
  toggleTip();

  function toggleTip(){
    console.log("cb-tip clicked!");
    var node = svg.selectAll(".node");
    tipEnalbed = !tipEnalbed;
    if (tipEnalbed) {
        svg.call(tip);
        node.on('mouseover', tip.show);
        node.on('mouseout', tip.hide);
    } else {
        node.on('mouseover', null);
        node.on('mouseout', null);
    }
    zoomToggle.node().innerText = 'Zoom is ' + (zoomEnabled ? 'enabled' : 'disabled');
}; 

  // svg.call(tip);

    // define the nodes
    var node = svg.append("g").selectAll(".node")
      .data(nodes)
      .enter()
      .append("g")
      .on('dblclick', releasenode)
      .call(node_drag)
      .on('mouseover', tip.show)
      .on('mouseout', tip.hide)
      // hari: how node info on click
      .on("click", function (d) {
        d3.select("#info")
        .property("value", d.id);
        console.log(d.id);
      });


    node.append("circle")
      .attr("class", function(d) {
        var labels = "node";
        if (d.type == 'rxn') {
          labels = labels.concat(" " + d.type + " hidden");
        } else {
          labels = labels.concat(" metabolite");
        }
        if ('flux' in d.notes.map_info) {
          if (d.notes.map_info.flux == 0) {
            labels = labels.concat(" inactive");
          }
        }
        return labels;
      })
      .attr("id", function(d) { return "_" + d.id; })
      .attr("r", 5)
      .style("fill", function(d) { 
        if (d.type != 'rxn') {
          if ('color' in d.notes.map_info) {
            return d.notes.map_info.color;
          } else {
            return '#1f77b4';
          }
        } else return "";
      });

    
    // test            
    // add the text 
    var text = node.append("text")
      .attr("class", function(d) {
        var labels = "nodelabel";
        if ('cofactor' in d) {
          labels = labels.concat(" cofactor");
        }
        if ('flux' in d.notes.map_info) {
          if (d.notes.map_info.flux == 0) {
            labels = labels.concat(" inactive");
          }
        }
        if (d.type == 'rxn') {
	  labels = labels.concat(" rxn");
        }
        return labels;
      })
      .attr("id", function(d) {return d.id})

      .attr("y", function(d) {
        if ('align' in d.notes.map_info) {
          if (d.notes.map_info.align.indexOf("upper") !== -1) {
            return '-.65em';
          }
          else if (d.notes.map_info.align.indexOf("lower") !== -1) {
            return '1.35em';
          }
          else {
            return '.35em';
          }
        } else {
          return '.35em';
        }
      })
      .attr("text-anchor", function(d) {
        if ('align' in d.notes.map_info) {
          if (d.notes.map_info.align.indexOf("left") !== -1) {
            return 'end';
          }
          else if (d.notes.map_info.align.indexOf("center") !== -1) {
            return 'middle';
          }
          else {
            return 'start';
          }
        } else {
          return 'start';
        }
      });
      // .text(function(d) { 
      //   if ('map_info' in d.notes) {
      //     if ('display_name' in d.notes.map_info) {
      //       return d.notes.map_info.display_name;
      //     }}});
      
    text.selectAll("tspan.text")
      .data(function(d) { 
        if ('map_info' in d.notes) {
          if ('display_name' in d.notes.map_info) {
            return d.notes.map_info.display_name.split('\n').map(function(item, index) {
                 return {
                   text : item,
                   notes : d.notes,
                   index : index
                 }})
          }
        }
        // Must not have returned a display name, return the metabolite name
        // instead
        return [{text: d.name, notes: d.notes, index: 0}]; 
      })
      .enter()
      .append("tspan")
      .attr("class", "text")
      .text(d => d.text)
      .attr("dy", function(d) {
        if (d.index == 0) {
          return "0"
        } else {
          return "1.2em"
        }
      })
      .attr("x", function(d) {
        if ('align' in d.notes.map_info) {
          if (d.notes.map_info.align.indexOf("left") !== -1) {
            if ((d.notes.map_info.align.indexOf("upper") !== -1) || 
                (d.notes.map_info.align.indexOf("lower") !== -1)) {
              return '-.6em';
            }
            else {
              return '-.9em';
            }
          }
          else if (d.notes.map_info.align.indexOf("center") !== -1) {
            return '0em';
          }
          else {
            if ((d.notes.map_info.align.indexOf("upper") !== -1) ||
                (d.notes.map_info.align.indexOf("lower") !== -1)) {
              return '.6em';
            }
            else {
              return '.9em';
            }
          }
        }
        else {
          return '.9em';
        }
      });

    var updateNode = function() {
      this.attr("transform", function(d) {
        return "translate(" + Math.max(0, Math.min(width, d.x)) + ","
          + Math.max(0, Math.min(height, d.y)) + ")";
      });
    }

    var updateAnchorLink = function() {
      this.attr("x1", function(d) {
        return d.source.x;
      }).attr("y1", function(d) {
        return d.source.y;
      }).attr("x2", function(d) {
        return d.target.x;
      }).attr("y2", function(d) {
        return d.target.y;
      });
    }

    var updateLink = function() {
        try {
          this.attr("d", function(d) {
            return calculate_path(d, force, Math.max(this.getTotalLength(), 15));
          });
        }
        catch(err) {
          return '';
        }
    }

    var updateAnchorNodes = function() {
      this.each(function(d, i) {
        if(i % 2 == 0) {
          d.x = d.node.x;
          d.y = d.node.y;
        } else {
          var b = this.childNodes[1].getBBox();

          var diffX = d.x - d.node.x;
          var diffY = d.y - d.node.y;

          var dist = Math.sqrt(diffX * diffX + diffY * diffY);

          var shiftX = b.width * (diffX - dist) / (dist * 2);
          shiftX = Math.max(-b.width, Math.min(0, shiftX));
          var shiftY = 5;
          this.childNodes[1].setAttribute("transform", "translate(" + shiftX + "," + shiftY + ")");
        }
      });
    }

    force.on("tick", function() {
      link.call(updateLink);
      node.call(updateNode);
    });

    // flux_scale = d3.scale.pow().exponent(1/2)
    flux_scale = d3.scale.linear()
      .domain([d3.min(fluxes), d3.max(fluxes)])
      .range([1.5, 6]);

    // metabolite_scale = d3.scale.pow().exponent(1/2)
    metabolite_scale = d3.scale.linear()
      .domain([d3.min(mfluxes), d3.max(mfluxes)])
      .range([4, 8]);

    arrowhead_scale = d3.scale.linear()
      .domain([1.5, 6])
      .range([6, 12]);

    function get_flux_width (rxn) {
      try {
        var flux = flux_scale(Math.abs(rxn.notes.map_info.flux));
        if (!isNaN(flux)) {
          return flux;
        } else{
          return 2.5;
        }
      }
      catch(err) {
        return 2.5; // Default linewidth
      }
    }

    function get_flux_dasharray (d) {
      try {
        if (d.rxn.notes.map_info.group == 'ko') {
          return "5, 5, 1, 5";
        }
        else if (Math.abs(d.rxn.notes.map_info.flux) < 1E-6) {
          return "5,5";
        }
      }
      catch(err) {
        return;
      }
    }

    function get_flux_stroke (d) {
      if ('color' in d.notes.map_info) {
        return d.notes.map_info.color;
      } else {
          return rxncolor(d.notes.map_info.group);
        }
    }

    function markerscale (d) {
      return arrowhead_scale(get_flux_width(d)) + "pt";
    }

    function get_node_radius (d) {
      if ('cofactor' in d) {return 4;}
      try {
        var nodewidth = metabolite_scale(Math.abs(d.notes.map_info.flux));
        if (!isNaN(nodewidth)) {
          return nodewidth;
        } else {
          return 5;
        }
      }
      catch(err){ return 5; }
    }






    // Node selection effect
    svg.selectAll("circle").on("mouseover", function(){
        d3.select(this)
        .style("fill", "red");
    })

  //   var focus_node = "null";
  //   svg.selectAll("circle").on("click", function(){
  //     if (focus_node == "null") {
  //       focus_node = d3.select(this);
  //       console.log(focus_node);
  //       d3.select(focus_node)
  //       .style("fill", "red");
  //     }
  //     else {
  //       d3.select(focus_node)
  //       .style("fill", function(d) { 
  //         if (d.type != 'rxn') {
  //           if ('color' in d.notes.map_info) {
  //             return d.notes.map_info.color;
  //           } else {
  //             return '#1f77b4';
  //           }
  //         } else return "";});

  //         // focus_node = d3.select(this);
  //         // d3.select(focus_node)
  //         // .style("fill", "red");
  //     }

  // })

    svg.selectAll("circle").on("mouseout", function(){
      d3.select(this)
      .style("fill", function(d) { 
        if (d.type != 'rxn') {
          if ('color' in d.notes.map_info) {
            return d.notes.map_info.color;
          } else {
            return '#1f77b4';
          }
        } else return "";});
  })


    // hari: !important
    svg.selectAll(".link")
      .attr("stroke-width", function (d) {return get_flux_width(d.rxn);})
      .attr("stroke", function (d) {return get_flux_stroke(d.rxn);})
      .attr("stroke-dasharray", get_flux_dasharray);

    svg.selectAll("marker")
      .attr("markerWidth", markerscale)
      .attr("markerHeight", markerscale)
      .select("path")
      .attr("fill", get_flux_stroke);

    //btn test
    // d3.select("#d3flux001_options .marker_button").on("click", function() {
    //   svg.selectAll("marker")
    //   .select("path")
    //   .transition()
    //   .style("fill", "purple");
    // });

    d3.select("#d3flux001_options .path_button").on("click", function() {
      svg.selectAll(".link")
      // color is not effective
      .transition()
      .style("stroke", "#006633");
    });

    d3.select("#d3flux001_options .reset_button").on("click", function() {
      svg.selectAll(".link")
      // color is not effective
      .transition()
      .style("stroke", function (d) {return get_flux_stroke(d.rxn);});

      svg.selectAll("marker")
      .select("path")
      .transition()
      .style("fill", get_flux_stroke);

      svg.selectAll("circle")
      .transition()
      .style("fill", function(d) { 
        if (d.type != 'rxn') {
          if ('color' in d.notes.map_info) {
            return d.notes.map_info.color;
          } else {
            return '#1f77b4';
          }
        } else return "";});

    });

    d3.select("#d3flux001_options .animate_button").on("click", function() {
      //svg.selectAll(".metabolite")
      graph = new Graph();
      // add unhidden metabolites

      // nodes.forEach(function(metabolite) {
      //   //graph.vertices.addVertex(metabolite);
      //   console.log(metabolite.id);
      //   graph.addVertex(metabolite.id);
      // });

      bilinks.forEach(function(link, i) {
        //console.log(link.source.id, " -> ",link.target.id);
        // if (!link.source.id in graph.getVertives) {
        //   graph.addVertex(link.source.id);
        // }

        // _debug: can't use id cause id will be identical
        //console.log(link.source.id, " -> ",link.target.id);

        // Ignore cofacor nodes
        if(link.target.cofactor) {
          return;
        }
        //tar = link.target.id;
       // tar.pointed_edge = 
        graph.addVertex(link.source.id);
        graph.addVertex(link.target.id);
        graph.addEdge(link.source.id, link.target.id);

        if(link.rxn.notes["map_info"]["reversibility"] == true){
          console.log("reverse!")
          graph.addEdge(link.target.id, link.source.id);
        }
        // svg.select("#" + link.id)
        // .transition()
        // .duration(700)
        // .delay( i * 700)
        // .style("stroke", "#006633");

      });
      
      console.log(graph.toString());
      var count = 0;
      function printNode(value) {
        
        console.log('Visited vertex: ' + value);
        count++;
        svg.select("circle#" + "_" + value)
        .transition()
        .duration(700)
        .delay(count* 700)
        .style("fill", "red");
      }

      var select = d3.select("#info").property("value");
      graph.dfs(select, printNode);
    });


d3.select("#d3flux001_options .test_button").on("click", function () {
  d3.select("#info")
  .property("value", "test");
  graph = new Graph();
  var myVertices = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I'];
  for (var i = 0; i < myVertices.length; i++) {
    graph.addVertex(myVertices[i]);
  }
  graph.addEdge('A', 'B');
  graph.addEdge('A', 'C');
  graph.addEdge('A', 'D');
  graph.addEdge('C', 'D');
  graph.addEdge('C', 'G');
  graph.addEdge('D', 'G');
  graph.addEdge('D', 'H');
  graph.addEdge('B', 'E');
  graph.addEdge('B', 'F');
  graph.addEdge('E', 'I');
  console.log(graph.toString());

  function printNode(value) {
    console.log('Visited vertex: ' + value);
  }
  graph.dfs("B", printNode);

});


    svg.selectAll(".metabolite")
      .attr("r", get_node_radius);

    d3.select("#d3flux001_options .download")
      .on("click", function () {

        // Add position data to model nodes
        force.nodes().forEach(function (node) {
          if (node.fixed) {
            if (node.type == "rxn") {
              // Reaction object
              obj = $.grep(model.reactions, function(e){ return e.id == node.id; })[0];
              if (!("notes" in obj)) { obj.notes = {}; }
              if (!("map_info" in obj.notes)) { obj.notes.map_info = {}; }
              obj.notes.map_info['x'] = node.x;
              obj.notes.map_info['y'] = node.y;
            } else {
              // Look in metabolites
              if (!('cofactor' in node)) {
                obj = $.grep(model.metabolites, function(e){ return e.id == node.id; })[0];
                if (!("notes" in obj)) { obj.notes = {}; }
                if (!("map_info" in obj.notes)) { obj.notes.map_info = {}; }
                obj.notes.map_info['x'] = node.x;
                obj.notes.map_info['y'] = node.y;
              } else {
                rxn = $.grep(model.reactions, function(e){ 
                  return e.id == node.cofactor; })[0];
                rxn.notes.map_info.cofactors[node.notes.orig_id]['x'] = node.x
                rxn.notes.map_info.cofactors[node.notes.orig_id]['y'] = node.y
              }
            }
          }
        });

        var json = JSON.stringify(model);
        var blob = new Blob([json], {type: "application/json"});
        saveAs(blob, model.id + ".json");
      });
  }

  main(d3flux001model);


  

});


class Queue {
  constructor() {
    var items = [];
    this.enqueue = function (element) {
      items.push(element);
    };
    this.dequeue = function () {
      return items.shift();
    };
    this.front = function () {
      return items[0];
    };
    this.isEmpty = function () {
      return items.length == 0;
    };
    this.clear = function () {
      items = [];
    };
    this.size = function () {
      return items.length;
    };
    this.print = function () {
      console.log(items.toString());
    };
  }
}

// Graph function
class Graph {
  constructor() {
    var vertices = []; //存储图中所有的顶点名字
    var adjList = new Dictionary(); //用字典来存储邻接表
    this.addVertex = function (v) {
      // Ignore existed vertex.
      if (vertices.indexOf(v) in vertices) {
        return;
      }
      vertices.push(v);
      adjList.set(v, []); //顶点为键，字典值为空数组
    };
    this.addEdge = function (v, w) {
      adjList.get(v).push(w); //基于有向图
      //adjList.get(w).push(v); //基于无向图
    };
    this.hasVertex = function (v) {
      return v in vertices;
    }
    this.toString = function () {
      var s = '';
      for (var i = 0; i < vertices.length; i++) {
        s += vertices[i] + ' -> ';
        var neighbors = adjList.get(vertices[i]);
        for (var j = 0; j < neighbors.length; j++) {
          s += neighbors[j] + ' ';
        }
        s += '\n';
      }
      return s;
    };
    var initializeColor = function () {
      var color = [];
      for (var i = 0; i < vertices.length; i++) {
        color[vertices[i]] = 'white';
      }
      return color;
    };

    

    this.dfs2 = function (s, callback) {
      var color = initializeColor(); //前面的颜色数组
      // for (var i=0; i<vertices.length; i++){
      //     if (color[vertices[i]] === 'white'){
      //         dfsVisit(vertices[i], color, callback); //递归调用未被访问过的顶点
      //     }
      // }
      if (color[s] == "white") {
        dfsVisit2(s, color, callback);
      }
    };
    var dfsVisit2 = function (u, color, callback) {
      color[u] = 'grey';
      if (callback) {
        callback(u);
      }
      var neighbors = adjList.get(u); //邻接表


      for (var i = 0; i < neighbors.length; i++) {
        var w = neighbors[i];
        // Stop recursion when end vertex is visted.
        if (neighbors.length == 0)
        {
          color[u] = 'black';
          callback(u);
          return;
        }

        if (color[w] === 'white') {
          dfsVisit2(w, color, callback); //添加顶点w入栈
        }

      }
      color[u] = 'black';
    };


    this.dfs = function (s, callback) {
      var color = initializeColor(); //前面的颜色数组
      // for (var i=0; i<vertices.length; i++){
      //     if (color[vertices[i]] === 'white'){
      //         dfsVisit(vertices[i], color, callback); //递归调用未被访问过的顶点
      //     }
      // }
      if (color[s] == "white") {
        dfsVisit(s, color, callback);
      }
    };
    var dfsVisit = function (u, color, callback) {
      color[u] = 'grey';
      if (callback) {
        callback(u);
      }
      var neighbors = adjList.get(u); //邻接表
      for (var i = 0; i < neighbors.length; i++) {
        var w = neighbors[i];
        if (color[w] === 'white') {
          dfsVisit(w, color, callback); //添加顶点w入栈
        }
      }
      color[u] = 'black';
    };

    this.bfs = function (v, callback) {
      var color = initializeColor(),
        queue = new Queue(); //创建一个队列
      queue.enqueue(v); //入队列
      while (!queue.isEmpty()) {
        var u = queue.dequeue(), //出队列
          neighbors = adjList.get(u); //邻接表
        color[u] = 'grey'; //发现了但还未完成对其的搜素
        for (var i = 0; i < neighbors.length; i++) {
          var w = neighbors[i]; //顶点名
          if (color[w] === 'white') {
            color[w] = 'grey'; //发现了它
            queue.enqueue(w); //入队列循环
          }
        }
        color[u] = 'black'; //已搜索过
        if (callback) {
          callback(u);
        }
      }
    };

  }
}

// Class Dictionary
class Dictionary {
  constructor() {
    var items = {};
    this.set = function (key, value) {
      items[key] = value;
    };
    this.remove = function (key) {
      if (this.has(key)) {
        delete items[key];
        return true;
      }
      return false;
    };
    this.has = function (key) {
      return items.hasOwnProperty(key);
    };
    this.get = function (key) {
      return this.has(key) ? items[key] : undefined;
    };
    this.clear = function () {
      items = {};
    };
    this.size = function () {
      return Object.keys(items).length;
    };
    this.keys = function () {
      return Object.keys(items);
    };
    this.values = function () {
      var values = [];
      for (var k in items) {
        if (this.has(k)) {
          values.push(items[k]);
        }
      }
      return values;
    };
    this.each = function (fn) {
      for (var k in items) {
        if (this.has(k)) {
          fn(k, items[k]);
        }
      }
    };
    this.getItems = function () {
      return items;
    };
  }
}











function Point(x, y) {
    this.x = x;
    this.y = y;
}

function quadraticBezierLength(p0, p1, p2) {
    var a = new Point(
        p0.x - 2 * p1.x + p2.x,
        p0.y - 2 * p1.y + p2.y
    );
    var b = new Point(
        2 * p1.x - 2 * p0.x,
        2 * p1.y - 2 * p0.y
    );
    var A = 4 * (a.x * a.x + a.y * a.y);
    var B = 4 * (a.x * b.x + a.y * b.y);
    var C = b.x * b.x + b.y * b.y;

    var Sabc = 2 * Math.sqrt(A+B+C);
    var A_2 = Math.sqrt(A);
    var A_32 = 2 * A * A_2;
    var C_2 = 2 * Math.sqrt(C);
    var BA = B / A_2;

    return (A_32 * Sabc + A_2 * B * (Sabc - C_2) + (4 * C * A - B * B) * Math.log((2 * A_2 + BA + Sabc) / (BA + C_2))) / (4 * A_32);
}


/*****
*
*   Point2D.js
*
*   copyright 2001-2002, Kevin Lindsey
*
*****/

/*****
*
*   Point2D
*
*****/

/*****
*
*   constructor
*
*****/
function Point2D(x, y) {
    if ( arguments.length > 0 ) {
        this.x = x;
        this.y = y;
    }
}


/*****
*
*   clone
*
*****/
Point2D.prototype.clone = function() {
    return new Point2D(this.x, this.y);
};


/*****
*
*   add
*
*****/
Point2D.prototype.add = function(that) {
    return new Point2D(this.x+that.x, this.y+that.y);
};


/*****
*
*   addEquals
*
*****/
Point2D.prototype.addEquals = function(that) {
    this.x += that.x;
    this.y += that.y;

    return this;
};


/*****
*
*   offset - used in dom_graph
*
*   This method is based on code written by Walter Korman
*      http://www.go2net.com/internet/deep/1997/05/07/body.html 
*   which is in turn based on an algorithm by Sven Moen
*
*****/
Point2D.prototype.offset = function(a, b) {
    var result = 0;

    if ( !( b.x <= this.x || this.x + a.x <= 0 ) ) {
        var t = b.x * a.y - a.x * b.y;
        var s;
        var d;

        if ( t > 0 ) {
            if ( this.x < 0 ) {
                s = this.x * a.y;
                d = s / a.x - this.y;
            } else if ( this.x > 0 ) {
                s = this.x * b.y;
                d = s / b.x - this.y
            } else {
                d = -this.y;
            }
        } else {
            if ( b.x < this.x + a.x ) {
                s = ( b.x - this.x ) * a.y;
                d = b.y - (this.y + s / a.x);
            } else if ( b.x > this.x + a.x ) {
                s = (a.x + this.x) * b.y;
                d = s / b.x - (this.y + a.y);
            } else {
                d = b.y - (this.y + a.y);
            }
        }

        if ( d > 0 ) {
            result = d;
        }
    }

    return result;
};


/*****
*
*   rmoveto
*
*****/
Point2D.prototype.rmoveto = function(dx, dy) {
    this.x += dx;
    this.y += dy;
};


/*****
*
*   scalarAdd
*
*****/
Point2D.prototype.scalarAdd = function(scalar) {
    return new Point2D(this.x+scalar, this.y+scalar);
};


/*****
*
*   scalarAddEquals
*
*****/
Point2D.prototype.scalarAddEquals = function(scalar) {
    this.x += scalar;
    this.y += scalar;

    return this;
};


/*****
*
*   subtract
*
*****/
Point2D.prototype.subtract = function(that) {
    return new Point2D(this.x-that.x, this.y-that.y);
};


/*****
*
*   subtractEquals
*
*****/
Point2D.prototype.subtractEquals = function(that) {
    this.x -= that.x;
    this.y -= that.y;

    return this;
};


/*****
*
*   scalarSubtract
*
*****/
Point2D.prototype.scalarSubtract = function(scalar) {
    return new Point2D(this.x-scalar, this.y-scalar);
};


/*****
*
*   scalarSubtractEquals
*
*****/
Point2D.prototype.scalarSubtractEquals = function(scalar) {
    this.x -= scalar;
    this.y -= scalar;

    return this;
};


/*****
*
*   multiply
*
*****/
Point2D.prototype.multiply = function(scalar) {
    return new Point2D(this.x*scalar, this.y*scalar);
};


/*****
*
*   multiplyEquals
*
*****/
Point2D.prototype.multiplyEquals = function(scalar) {
    this.x *= scalar;
    this.y *= scalar;

    return this;
};


/*****
*
*   divide
*
*****/
Point2D.prototype.divide = function(scalar) {
    return new Point2D(this.x/scalar, this.y/scalar);
};


/*****
*
*   divideEquals
*
*****/
Point2D.prototype.divideEquals = function(scalar) {
    this.x /= scalar;
    this.y /= scalar;

    return this;
};


/*****
*
*   comparison methods
*
*   these were a nice idea, but ...  It would be better to define these names
*   in two parts so that the first part is the x comparison and the second is
*   the y.  For example, to test p1.x < p2.x and p1.y >= p2.y, you would call
*   p1.lt_gte(p2).  Honestly, I only did these types of comparisons in one
*   Intersection routine, so these probably could be removed.
*
*****/

/*****
*
*   compare
*
*****/
Point2D.prototype.compare = function(that) {
    return (this.x - that.x || this.y - that.y);
};


/*****
*
*   eq - equal
*
*****/
Point2D.prototype.eq = function(that) {
    return ( this.x == that.x && this.y == that.y );
};


/*****
*
*   lt - less than
*
*****/
Point2D.prototype.lt = function(that) {
    return ( this.x < that.x && this.y < that.y );
};


/*****
*
*   lte - less than or equal
*
*****/
Point2D.prototype.lte = function(that) {
    return ( this.x <= that.x && this.y <= that.y );
};


/*****
*
*   gt - greater than
*
*****/
Point2D.prototype.gt = function(that) {
    return ( this.x > that.x && this.y > that.y );
};


/*****
*
*   gte - greater than or equal
*
*****/
Point2D.prototype.gte = function(that) {
    return ( this.x >= that.x && this.y >= that.y );
};


/*****
*
*   utility methods
*
*****/

/*****
*
*   lerp
*
*****/
Point2D.prototype.lerp = function(that, t) {
    return new Point2D(
        this.x + (that.x - this.x) * t,
        this.y + (that.y - this.y) * t
    );
};


/*****
*
*   distanceFrom
*
*****/
Point2D.prototype.distanceFrom = function(that) {
    var dx = this.x - that.x;
    var dy = this.y - that.y;

    return Math.sqrt(dx*dx + dy*dy);
};


/*****
*
*   min
*
*****/
Point2D.prototype.min = function(that) {
    return new Point2D(
        Math.min( this.x, that.x ),
        Math.min( this.y, that.y )
    );
};


/*****
*
*   max
*
*****/
Point2D.prototype.max = function(that) {
    return new Point2D(
        Math.max( this.x, that.x ),
        Math.max( this.y, that.y )
    );
};


/*****
*
*   toString
*
*****/
Point2D.prototype.toString = function() {
    return this.x + "," + this.y;
};


/*****
*
*   get/set methods
*
*****/

/*****
*
*   setXY
*
*****/
Point2D.prototype.setXY = function(x, y) {
    this.x = x;
    this.y = y;
};


/*****
*
*   setFromPoint
*
*****/
Point2D.prototype.setFromPoint = function(that) {
    this.x = that.x;
    this.y = that.y;
};


/*****
*
*   swap
*
*****/
Point2D.prototype.swap = function(that) {
    var x = this.x;
    var y = this.y;

    this.x = that.x;
    this.y = that.y;

    that.x = x;
    that.y = y;
};

/*****
*
*   Polynomial.js
*
*   copyright 2002, Kevin Lindsey
*
*****/

Polynomial.TOLERANCE = 1e-6;
Polynomial.ACCURACY  = 6;


/*****
*
*   interpolate - class method
*
*****/
Polynomial.interpolate = function(xs, ys, n, offset, x) {
    if ( xs.constructor !== Array || ys.constructor !== Array )
        throw new Error("Polynomial.interpolate: xs and ys must be arrays");
    if ( isNaN(n) || isNaN(offset) || isNaN(x) )
        throw new Error("Polynomial.interpolate: n, offset, and x must be numbers");

    var y  = 0;
    var dy = 0;
    var c = new Array(n);
    var d = new Array(n);
    var ns = 0;
    var result;

    var diff = Math.abs(x - xs[offset]);
    for ( var i = 0; i < n; i++ ) {
        var dift = Math.abs(x - xs[offset+i]);

        if ( dift < diff ) {
            ns = i;
            diff = dift;
        }
        c[i] = d[i] = ys[offset+i];
    }
    y = ys[offset+ns];
    ns--;

    for ( var m = 1; m < n; m++ ) {
        for ( var i = 0; i < n-m; i++ ) {
            var ho = xs[offset+i] - x;
            var hp = xs[offset+i+m] - x;
            var w = c[i+1]-d[i];
            var den = ho - hp;

            if ( den == 0.0 ) {
                result = { y: 0, dy: 0};
                break;
            }

            den = w / den;
            d[i] = hp*den;
            c[i] = ho*den;
        }
        dy = (2*(ns+1) < (n-m)) ? c[ns+1] : d[ns--];
        y += dy;
    }

    return { y: y, dy: dy };
};


/*****
*
*   constructor
*
*****/
function Polynomial() {
    this.init( arguments );
}


/*****
*
*   init
*
*****/
Polynomial.prototype.init = function(coefs) {
    this.coefs = new Array();

    for ( var i = coefs.length - 1; i >= 0; i-- )
        this.coefs.push( coefs[i] );

    this._variable = "t";
    this._s = 0;
};


/*****
*
*   eval
*
*****/
Polynomial.prototype.eval = function(x) {
    if ( isNaN(x) )
        throw new Error("Polynomial.eval: parameter must be a number");

    var result = 0;

    for ( var i = this.coefs.length - 1; i >= 0; i-- )
        result = result * x + this.coefs[i];

    return result;
};


/*****
*
*   add
*
*****/
Polynomial.prototype.add = function(that) {
    var result = new Polynomial();
    var d1 = this.getDegree();
    var d2 = that.getDegree();
    var dmax = Math.max(d1,d2);

    for ( var i = 0; i <= dmax; i++ ) {
        var v1 = (i <= d1) ? this.coefs[i] : 0;
        var v2 = (i <= d2) ? that.coefs[i] : 0;

        result.coefs[i] = v1 + v2;
    }

    return result;
};


/*****
*
*   multiply
*
*****/
Polynomial.prototype.multiply = function(that) {
    var result = new Polynomial();

    for ( var i = 0; i <= this.getDegree() + that.getDegree(); i++ )
        result.coefs.push(0);

    for ( var i = 0; i <= this.getDegree(); i++ )
        for ( var j = 0; j <= that.getDegree(); j++ )
            result.coefs[i+j] += this.coefs[i] * that.coefs[j];

    return result;
};


/*****
*
*   divide_scalar
*
*****/
Polynomial.prototype.divide_scalar = function(scalar) {
    for ( var i = 0; i < this.coefs.length; i++ )
        this.coefs[i] /= scalar;
};


/*****
*
*   simplify
*
*****/
Polynomial.prototype.simplify = function() {
    for ( var i = this.getDegree(); i >= 0; i-- ) {
        if ( Math.abs( this.coefs[i] ) <= Polynomial.TOLERANCE )
            this.coefs.pop();
        else
            break;
    }
};


/*****
*
*   bisection
*
*****/
Polynomial.prototype.bisection = function(min, max) {
    var minValue = this.eval(min);
    var maxValue = this.eval(max);
    var result;
    
    if ( Math.abs(minValue) <= Polynomial.TOLERANCE )
        result = min;
    else if ( Math.abs(maxValue) <= Polynomial.TOLERANCE )
        result = max;
    else if ( minValue * maxValue <= 0 ) {
        var tmp1  = Math.log(max - min);
        var tmp2  = Math.LN10 * Polynomial.ACCURACY;
        var iters = Math.ceil( (tmp1+tmp2) / Math.LN2 );

        for ( var i = 0; i < iters; i++ ) {
            result = 0.5 * (min + max);
            var value = this.eval(result);

            if ( Math.abs(value) <= Polynomial.TOLERANCE ) {
                break;
            }

            if ( value * minValue < 0 ) {
                max = result;
                maxValue = value;
            } else {
                min = result;
                minValue = value;
            }
        }
    }

    return result;
};


/*****
*
*   toString
*
*****/
Polynomial.prototype.toString = function() {
    var coefs = new Array();
    var signs = new Array();
    
    for ( var i = this.coefs.length - 1; i >= 0; i-- ) {
        var value = Math.round(this.coefs[i]*1000)/1000;
        //var value = this.coefs[i];

        if ( value != 0 ) {
            var sign = ( value < 0 ) ? " - " : " + ";

            value = Math.abs(value);
            if ( i > 0 )
                if ( value == 1 )
                    value = this._variable;
                else
                    value += this._variable;
            if ( i > 1 ) value += "^" + i;

            signs.push( sign );
            coefs.push( value );
        }
    }

    signs[0] = ( signs[0] == " + " ) ? "" : "-";

    var result = "";
    for ( var i = 0; i < coefs.length; i++ )
        result += signs[i] + coefs[i];
    
    return result;
};


/*****
*
*   trapezoid
*   Based on trapzd in "Numerical Recipes in C", page 137
*
*****/
Polynomial.prototype.trapezoid = function(min, max, n) {
    if ( isNaN(min) || isNaN(max) || isNaN(n) )
        throw new Error("Polynomial.trapezoid: parameters must be numbers");

    var range = max - min;
    var TOLERANCE = 1e-7;

    if ( n == 1 ) {
        var minValue = this.eval(min);
        var maxValue = this.eval(max);
        this._s = 0.5*range*( minValue + maxValue );
    } else {
        var it = 1 << (n-2);
        var delta = range / it;
        var x = min + 0.5*delta;
        var sum = 0;

        for ( var i = 0; i < it; i++ ) {
            sum += this.eval(x);
            x += delta;
        }
        this._s = 0.5*(this._s + range*sum/it);
    }

    if ( isNaN(this._s) )
        throw new Error("Polynomial.trapezoid: this._s is NaN");

    return this._s;
};


/*****
*
*   simpson
*   Based on trapzd in "Numerical Recipes in C", page 139
*
*****/
Polynomial.prototype.simpson = function(min, max) {
    if ( isNaN(min) || isNaN(max) )
        throw new Error("Polynomial.simpson: parameters must be numbers");

    var range = max - min;
    var st = 0.5 * range * ( this.eval(min) + this.eval(max) );
    var t = st;
    var s = 4.0*st/3.0;
    var os = s;
    var ost = st;
    var TOLERANCE = 1e-7;

    var it = 1;
    for ( var n = 2; n <= 20; n++ ) {
        var delta = range / it;
        var x     = min + 0.5*delta;
        var sum   = 0;

        for ( var i = 1; i <= it; i++ ) {
            sum += this.eval(x);
            x += delta;
        }

        t = 0.5 * (t + range * sum / it);
        st = t;
        s = (4.0*st - ost)/3.0;

        if ( Math.abs(s-os) < TOLERANCE*Math.abs(os) )
            break;

        os = s;
        ost = st;
        it <<= 1;
    }

    return s;
};


/*****
*
*   romberg
*
*****/
Polynomial.prototype.romberg = function(min, max) {
    if ( isNaN(min) || isNaN(max) )
        throw new Error("Polynomial.romberg: parameters must be numbers");

    var MAX = 20;
    var K = 3;
    var TOLERANCE = 1e-6;
    var s = new Array(MAX+1);
    var h = new Array(MAX+1);
    var result = { y: 0, dy: 0 };

    h[0] = 1.0;
    for ( var j = 1; j <= MAX; j++ ) {
        s[j-1] = this.trapezoid(min, max, j);
        if ( j >= K ) {
            result = Polynomial.interpolate(h, s, K, j-K, 0.0);
            if ( Math.abs(result.dy) <= TOLERANCE*result.y) break;
        }
        s[j] = s[j-1];
        h[j] = 0.25 * h[j-1];
    }

    return result.y;
};


/*****
*
*   get/set methods
*
*****/

/*****
*
*   get degree
*
*****/
Polynomial.prototype.getDegree = function() {
    return this.coefs.length - 1;
};


/*****
*
*   getDerivative
*
*****/
Polynomial.prototype.getDerivative = function() {
    var derivative = new Polynomial();

    for ( var i = 1; i < this.coefs.length; i++ ) {
        derivative.coefs.push(i*this.coefs[i]);
    }

    return derivative;
};


/*****
*
*   getRoots
*
*****/
Polynomial.prototype.getRoots = function() {
    var result;

    this.simplify();
    switch ( this.getDegree() ) {
        case 0: result = new Array();              break;
        case 1: result = this.getLinearRoot();     break;
        case 2: result = this.getQuadraticRoots(); break;
        case 3: result = this.getCubicRoots();     break;
        case 4: result = this.getQuarticRoots();   break;
        default:
            result = new Array();
            // should try Newton's method and/or bisection
    }

    return result;
};


/*****
*
*   getRootsInInterval
*
*****/
Polynomial.prototype.getRootsInInterval = function(min, max) {
    var roots = new Array();
    var root;

    if ( this.getDegree() == 1 ) {
        root = this.bisection(min, max);
        if ( root != null ) roots.push(root);
    } else {
        // get roots of derivative
        var deriv  = this.getDerivative();
        var droots = deriv.getRootsInInterval(min, max);

        if ( droots.length > 0 ) {
            // find root on [min, droots[0]]
            root = this.bisection(min, droots[0]);
            if ( root != null ) roots.push(root);

            // find root on [droots[i],droots[i+1]] for 0 <= i <= count-2
            for ( i = 0; i <= droots.length-2; i++ ) {
                root = this.bisection(droots[i], droots[i+1]);
                if ( root != null ) roots.push(root);
            }

            // find root on [droots[count-1],xmax]
            root = this.bisection(droots[droots.length-1], max);
            if ( root != null ) roots.push(root);
        } else {
            // polynomial is monotone on [min,max], has at most one root
            root = this.bisection(min, max);
            if ( root != null ) roots.push(root);
        }
    }

    return roots;
};


/*****
*
*   getLinearRoot
*
*****/
Polynomial.prototype.getLinearRoot = function() {
    var result = new Array();
    var a = this.coefs[1];
    
    if ( a != 0 )
        result.push( -this.coefs[0] / a );

    return result;
};


/*****
*
*   getQuadraticRoots
*
*****/
Polynomial.prototype.getQuadraticRoots = function() {
    var results = new Array();

    if ( this.getDegree() == 2 ) {
        var a = this.coefs[2];
        var b = this.coefs[1] / a;
        var c = this.coefs[0] / a;
        var d = b*b - 4*c;

        if ( d > 0 ) {
            var e = Math.sqrt(d);
            
            results.push( 0.5 * (-b + e) );
            results.push( 0.5 * (-b - e) );
        } else if ( d == 0 ) {
            // really two roots with same value, but we only return one
            results.push( 0.5 * -b );
        }
    }

    return results;
};


/*****
*
*   getCubicRoots
*
*   This code is based on MgcPolynomial.cpp written by David Eberly.  His
*   code along with many other excellent examples are avaiable at his site:
*   http://www.magic-software.com
*
*****/
Polynomial.prototype.getCubicRoots = function() {
    var results = new Array();

    if ( this.getDegree() == 3 ) {
        var c3 = this.coefs[3];
        var c2 = this.coefs[2] / c3;
        var c1 = this.coefs[1] / c3;
        var c0 = this.coefs[0] / c3;

        var a       = (3*c1 - c2*c2) / 3;
        var b       = (2*c2*c2*c2 - 9*c1*c2 + 27*c0) / 27;
        var offset  = c2 / 3;
        var discrim = b*b/4 + a*a*a/27;
        var halfB   = b / 2;

        if ( Math.abs(discrim) <= Polynomial.TOLERANCE ) discrim = 0;
        
        if ( discrim > 0 ) {
            var e = Math.sqrt(discrim);
            var tmp;
            var root;

            tmp = -halfB + e;
            if ( tmp >= 0 )
                root = Math.pow(tmp, 1/3);
            else
                root = -Math.pow(-tmp, 1/3);

            tmp = -halfB - e;
            if ( tmp >= 0 )
                root += Math.pow(tmp, 1/3);
            else
                root -= Math.pow(-tmp, 1/3);

            results.push( root - offset );
        } else if ( discrim < 0 ) {
            var distance = Math.sqrt(-a/3);
            var angle    = Math.atan2( Math.sqrt(-discrim), -halfB) / 3;
            var cos      = Math.cos(angle);
            var sin      = Math.sin(angle);
            var sqrt3    = Math.sqrt(3);

            results.push( 2*distance*cos - offset );
            results.push( -distance * (cos + sqrt3 * sin) - offset);
            results.push( -distance * (cos - sqrt3 * sin) - offset);
        } else {
            var tmp;

            if ( halfB >= 0 )
                tmp = -Math.pow(halfB, 1/3);
            else
                tmp = Math.pow(-halfB, 1/3);

            results.push( 2*tmp - offset );
            // really should return next root twice, but we return only one
            results.push( -tmp - offset );
        }
    }

    return results;
};


/*****
*
*   getQuarticRoots
*
*   This code is based on MgcPolynomial.cpp written by David Eberly.  His
*   code along with many other excellent examples are avaiable at his site:
*   http://www.magic-software.com
*
*****/
Polynomial.prototype.getQuarticRoots = function() {
    var results = new Array();

    if ( this.getDegree() == 4 ) {
        var c4 = this.coefs[4];
        var c3 = this.coefs[3] / c4;
        var c2 = this.coefs[2] / c4;
        var c1 = this.coefs[1] / c4;
        var c0 = this.coefs[0] / c4;

        var resolveRoots = new Polynomial(
            1, -c2, c3*c1 - 4*c0, -c3*c3*c0 + 4*c2*c0 -c1*c1
        ).getCubicRoots();
        var y       = resolveRoots[0];
        var discrim = c3*c3/4 - c2 + y;

        if ( Math.abs(discrim) <= Polynomial.TOLERANCE ) discrim = 0;

        if ( discrim > 0 ) {
            var e     = Math.sqrt(discrim);
            var t1    = 3*c3*c3/4 - e*e - 2*c2;
            var t2    = ( 4*c3*c2 - 8*c1 - c3*c3*c3 ) / ( 4*e );
            var plus  = t1+t2;
            var minus = t1-t2;

            if ( Math.abs(plus)  <= Polynomial.TOLERANCE ) plus  = 0;
            if ( Math.abs(minus) <= Polynomial.TOLERANCE ) minus = 0;

            if ( plus >= 0 ) {
                var f = Math.sqrt(plus);

                results.push( -c3/4 + (e+f)/2 );
                results.push( -c3/4 + (e-f)/2 );
            }
            if ( minus >= 0 ) {
                var f = Math.sqrt(minus);

                results.push( -c3/4 + (f-e)/2 );
                results.push( -c3/4 - (f+e)/2 );
            }
        } else if ( discrim < 0 ) {
            // no roots
        } else {
            var t2 = y*y - 4*c0;

            if ( t2 >= -Polynomial.TOLERANCE ) {
                if ( t2 < 0 ) t2 = 0;

                t2 = 2*Math.sqrt(t2);
                t1 = 3*c3*c3/4 - 2*c2;
                if ( t1+t2 >= Polynomial.TOLERANCE ) {
                    var d = Math.sqrt(t1+t2);

                    results.push( -c3/4 + d/2 );
                    results.push( -c3/4 - d/2 );
                }
                if ( t1-t2 >= Polynomial.TOLERANCE ) {
                    var d = Math.sqrt(t1-t2);

                    results.push( -c3/4 + d/2 );
                    results.push( -c3/4 - d/2 );
                }
            }
        }
    }

    return results;
};

/*****
*
*   Intersection.js
*
*   copyright 2002, Kevin Lindsey
*
*****/

/*****
*
*   constructor
*
*****/
function Intersection(status) {
    if ( arguments.length > 0 ) {
        this.init(status);
    }
}


/*****
*
*   init
*
*****/
Intersection.prototype.init = function(status) {
    this.status = status;
    this.points = new Array();
};


/*****
*
*   appendPoint
*
*****/
Intersection.prototype.appendPoint = function(point) {
    this.points.push(point);
};


/*****
*
*   appendPoints
*
*****/
Intersection.prototype.appendPoints = function(points) {
    this.points = this.points.concat(points);
};


/*****
*
*   class methods
*
*****/

/*****
*
*   intersectShapes
*
*****/
Intersection.intersectShapes = function(shape1, shape2) {
    var ip1 = shape1.getIntersectionParams();
    var ip2 = shape2.getIntersectionParams();
    var result;

    if ( ip1 != null && ip2 != null ) {
        if ( ip1.name == "Path" ) {
            result = Intersection.intersectPathShape(shape1, shape2);
        } else if ( ip2.name == "Path" ) {
            result = Intersection.intersectPathShape(shape2, shape1);
        } else {
            var method;
            var params;

            if ( ip1.name < ip2.name ) {
                method = "intersect" + ip1.name + ip2.name;
                params = ip1.params.concat( ip2.params );
            } else {
                method = "intersect" + ip2.name + ip1.name;
                params = ip2.params.concat( ip1.params );
            }

            if ( !(method in Intersection) )
                throw new Error("Intersection not available: " + method);

            result = Intersection[method].apply(null, params);
        }
    } else {
        result = new Intersection("No Intersection");
    }

    return result;
};


/*****
*
*   intersectPathShape
*
*****/
Intersection.intersectPathShape = function(path, shape) {
    return path.intersectShape(shape);
};


/*****
*
*   intersectBezier2Bezier2
*
*****/
Intersection.intersectBezier2Bezier2 = function(a1, a2, a3, b1, b2, b3) {
    var a, b;
    var c12, c11, c10;
    var c22, c21, c20;
    var result = new Intersection("No Intersection");
    var poly;

    a = a2.multiply(-2);
    c12 = a1.add(a.add(a3));

    a = a1.multiply(-2);
    b = a2.multiply(2);
    c11 = a.add(b);

    c10 = new Point2D(a1.x, a1.y);

    a = b2.multiply(-2);
    c22 = b1.add(a.add(b3));

    a = b1.multiply(-2);
    b = b2.multiply(2);
    c21 = a.add(b);

    c20 = new Point2D(b1.x, b1.y);
    
    if ( c12.y == 0 ) {
        var v0 = c12.x*(c10.y - c20.y);
        var v1 = v0 - c11.x*c11.y;
        var v2 = v0 + v1;
        var v3 = c11.y*c11.y;

        poly = new Polynomial(
            c12.x*c22.y*c22.y,
            2*c12.x*c21.y*c22.y,
            c12.x*c21.y*c21.y - c22.x*v3 - c22.y*v0 - c22.y*v1,
            -c21.x*v3 - c21.y*v0 - c21.y*v1,
            (c10.x - c20.x)*v3 + (c10.y - c20.y)*v1
        );
    } else {
        var v0 = c12.x*c22.y - c12.y*c22.x;
        var v1 = c12.x*c21.y - c21.x*c12.y;
        var v2 = c11.x*c12.y - c11.y*c12.x;
        var v3 = c10.y - c20.y;
        var v4 = c12.y*(c10.x - c20.x) - c12.x*v3;
        var v5 = -c11.y*v2 + c12.y*v4;
        var v6 = v2*v2;

        poly = new Polynomial(
            v0*v0,
            2*v0*v1,
            (-c22.y*v6 + c12.y*v1*v1 + c12.y*v0*v4 + v0*v5) / c12.y,
            (-c21.y*v6 + c12.y*v1*v4 + v1*v5) / c12.y,
            (v3*v6 + v4*v5) / c12.y
        );
    }

    var roots = poly.getRoots();
    for ( var i = 0; i < roots.length; i++ ) {
        var s = roots[i];

        if ( 0 <= s && s <= 1 ) {
            var xRoots = new Polynomial(
                c12.x,
                c11.x,
                c10.x - c20.x - s*c21.x - s*s*c22.x
            ).getRoots();
            var yRoots = new Polynomial(
                c12.y,
                c11.y,
                c10.y - c20.y - s*c21.y - s*s*c22.y
            ).getRoots();

            if ( xRoots.length > 0 && yRoots.length > 0 ) {
                var TOLERANCE = 1e-4;

                checkRoots:
                for ( var j = 0; j < xRoots.length; j++ ) {
                    var xRoot = xRoots[j];

                    if ( 0 <= xRoot && xRoot <= 1 ) {
                        for ( var k = 0; k < yRoots.length; k++ ) {
                            if ( Math.abs( xRoot - yRoots[k] ) < TOLERANCE ) {
                                result.points.push( c22.multiply(s*s).add(c21.multiply(s).add(c20)) );
                                break checkRoots;
                            }
                        }
                    }
                }
            }
        }
    }

    if ( result.points.length > 0 ) result.status = "Intersection";

    return result;
};


/*****
*
*   intersectBezier2Bezier3
*
*****/
Intersection.intersectBezier2Bezier3 = function(a1, a2, a3, b1, b2, b3, b4) {
    var a, b,c, d;
    var c12, c11, c10;
    var c23, c22, c21, c20;
    var result = new Intersection("No Intersection");

    a = a2.multiply(-2);
    c12 = a1.add(a.add(a3));

    a = a1.multiply(-2);
    b = a2.multiply(2);
    c11 = a.add(b);

    c10 = new Point2D(a1.x, a1.y);

    a = b1.multiply(-1);
    b = b2.multiply(3);
    c = b3.multiply(-3);
    d = a.add(b.add(c.add(b4)));
    c23 = new Vector2D(d.x, d.y);

    a = b1.multiply(3);
    b = b2.multiply(-6);
    c = b3.multiply(3);
    d = a.add(b.add(c));
    c22 = new Vector2D(d.x, d.y);

    a = b1.multiply(-3);
    b = b2.multiply(3);
    c = a.add(b);
    c21 = new Vector2D(c.x, c.y);

    c20 = new Vector2D(b1.x, b1.y);

    var c10x2 = c10.x*c10.x;
    var c10y2 = c10.y*c10.y;
    var c11x2 = c11.x*c11.x;
    var c11y2 = c11.y*c11.y;
    var c12x2 = c12.x*c12.x;
    var c12y2 = c12.y*c12.y;
    var c20x2 = c20.x*c20.x;
    var c20y2 = c20.y*c20.y;
    var c21x2 = c21.x*c21.x;
    var c21y2 = c21.y*c21.y;
    var c22x2 = c22.x*c22.x;
    var c22y2 = c22.y*c22.y;
    var c23x2 = c23.x*c23.x;
    var c23y2 = c23.y*c23.y;

    var poly = new Polynomial(
        -2*c12.x*c12.y*c23.x*c23.y + c12x2*c23y2 + c12y2*c23x2,
        -2*c12.x*c12.y*c22.x*c23.y - 2*c12.x*c12.y*c22.y*c23.x + 2*c12y2*c22.x*c23.x +
            2*c12x2*c22.y*c23.y,
        -2*c12.x*c21.x*c12.y*c23.y - 2*c12.x*c12.y*c21.y*c23.x - 2*c12.x*c12.y*c22.x*c22.y +
            2*c21.x*c12y2*c23.x + c12y2*c22x2 + c12x2*(2*c21.y*c23.y + c22y2),
        2*c10.x*c12.x*c12.y*c23.y + 2*c10.y*c12.x*c12.y*c23.x + c11.x*c11.y*c12.x*c23.y +
            c11.x*c11.y*c12.y*c23.x - 2*c20.x*c12.x*c12.y*c23.y - 2*c12.x*c20.y*c12.y*c23.x -
            2*c12.x*c21.x*c12.y*c22.y - 2*c12.x*c12.y*c21.y*c22.x - 2*c10.x*c12y2*c23.x -
            2*c10.y*c12x2*c23.y + 2*c20.x*c12y2*c23.x + 2*c21.x*c12y2*c22.x -
            c11y2*c12.x*c23.x - c11x2*c12.y*c23.y + c12x2*(2*c20.y*c23.y + 2*c21.y*c22.y),
        2*c10.x*c12.x*c12.y*c22.y + 2*c10.y*c12.x*c12.y*c22.x + c11.x*c11.y*c12.x*c22.y +
            c11.x*c11.y*c12.y*c22.x - 2*c20.x*c12.x*c12.y*c22.y - 2*c12.x*c20.y*c12.y*c22.x -
            2*c12.x*c21.x*c12.y*c21.y - 2*c10.x*c12y2*c22.x - 2*c10.y*c12x2*c22.y +
            2*c20.x*c12y2*c22.x - c11y2*c12.x*c22.x - c11x2*c12.y*c22.y + c21x2*c12y2 +
            c12x2*(2*c20.y*c22.y + c21y2),
        2*c10.x*c12.x*c12.y*c21.y + 2*c10.y*c12.x*c21.x*c12.y + c11.x*c11.y*c12.x*c21.y +
            c11.x*c11.y*c21.x*c12.y - 2*c20.x*c12.x*c12.y*c21.y - 2*c12.x*c20.y*c21.x*c12.y -
            2*c10.x*c21.x*c12y2 - 2*c10.y*c12x2*c21.y + 2*c20.x*c21.x*c12y2 -
            c11y2*c12.x*c21.x - c11x2*c12.y*c21.y + 2*c12x2*c20.y*c21.y,
        -2*c10.x*c10.y*c12.x*c12.y - c10.x*c11.x*c11.y*c12.y - c10.y*c11.x*c11.y*c12.x +
            2*c10.x*c12.x*c20.y*c12.y + 2*c10.y*c20.x*c12.x*c12.y + c11.x*c20.x*c11.y*c12.y +
            c11.x*c11.y*c12.x*c20.y - 2*c20.x*c12.x*c20.y*c12.y - 2*c10.x*c20.x*c12y2 +
            c10.x*c11y2*c12.x + c10.y*c11x2*c12.y - 2*c10.y*c12x2*c20.y -
            c20.x*c11y2*c12.x - c11x2*c20.y*c12.y + c10x2*c12y2 + c10y2*c12x2 +
            c20x2*c12y2 + c12x2*c20y2
    );
    var roots = poly.getRootsInInterval(0,1);

    for ( var i = 0; i < roots.length; i++ ) {
        var s = roots[i];
        var xRoots = new Polynomial(
            c12.x,
            c11.x,
            c10.x - c20.x - s*c21.x - s*s*c22.x - s*s*s*c23.x
        ).getRoots();
        var yRoots = new Polynomial(
            c12.y,
            c11.y,
            c10.y - c20.y - s*c21.y - s*s*c22.y - s*s*s*c23.y
        ).getRoots();

        if ( xRoots.length > 0 && yRoots.length > 0 ) {
            var TOLERANCE = 1e-4;

            checkRoots:
            for ( var j = 0; j < xRoots.length; j++ ) {
                var xRoot = xRoots[j];
                
                if ( 0 <= xRoot && xRoot <= 1 ) {
                    for ( var k = 0; k < yRoots.length; k++ ) {
                        if ( Math.abs( xRoot - yRoots[k] ) < TOLERANCE ) {
                            result.points.push(
                                c23.multiply(s*s*s).add(c22.multiply(s*s).add(c21.multiply(s).add(c20)))
                            );
                            break checkRoots;
                        }
                    }
                }
            }
        }
    }

    if ( result.points.length > 0 ) result.status = "Intersection";

    return result;

};


/*****
*
*   intersectBezier2Circle
*
*****/
Intersection.intersectBezier2Circle = function(p1, p2, p3, c, r) {
    return Intersection.intersectBezier2Ellipse(p1, p2, p3, c, r, r);
};


/*****
*
*   intersectBezier2Ellipse
*
*****/
Intersection.intersectBezier2Ellipse = function(p1, p2, p3, ec, rx, ry) {
    var a, b;       // temporary variables
    var c2, c1, c0; // coefficients of quadratic
    var result = new Intersection("No Intersection");

    a = p2.multiply(-2);
    c2 = p1.add(a.add(p3));

    a = p1.multiply(-2);
    b = p2.multiply(2);
    c1 = a.add(b);

    c0 = new Point2D(p1.x, p1.y);

    var rxrx  = rx*rx;
    var ryry  = ry*ry;
    var roots = new Polynomial(
        ryry*c2.x*c2.x + rxrx*c2.y*c2.y,
        2*(ryry*c2.x*c1.x + rxrx*c2.y*c1.y),
        ryry*(2*c2.x*c0.x + c1.x*c1.x) + rxrx*(2*c2.y*c0.y+c1.y*c1.y) -
            2*(ryry*ec.x*c2.x + rxrx*ec.y*c2.y),
        2*(ryry*c1.x*(c0.x-ec.x) + rxrx*c1.y*(c0.y-ec.y)),
        ryry*(c0.x*c0.x+ec.x*ec.x) + rxrx*(c0.y*c0.y + ec.y*ec.y) -
            2*(ryry*ec.x*c0.x + rxrx*ec.y*c0.y) - rxrx*ryry
    ).getRoots();

    function isValid(value) {
    return ( 0 <= value && value <= 1 );
  }

    return roots.filter(isValid).sort();

    // for ( var i = 0; i < roots.length; i++ ) {
    //     var t = roots[i];
    //
    //     if ( 0 <= t && t <= 1 )
    //         result.points.push( c2.multiply(t*t).add(c1.multiply(t).add(c0)) );
    // }

    // if ( result.points.length > 0 ) result.status = "Intersection";
    //
    // return result;
};


/*****
*
*   intersectBezier2Line
*
*****/
Intersection.intersectBezier2Line = function(p1, p2, p3, a1, a2) {
    var a, b;             // temporary variables
    var c2, c1, c0;       // coefficients of quadratic
    var cl;               // c coefficient for normal form of line
    var n;                // normal for normal form of line
    var min = a1.min(a2); // used to determine if point is on line segment
    var max = a1.max(a2); // used to determine if point is on line segment
    var result = new Intersection("No Intersection");
    
    a = p2.multiply(-2);
    c2 = p1.add(a.add(p3));

    a = p1.multiply(-2);
    b = p2.multiply(2);
    c1 = a.add(b);

    c0 = new Point2D(p1.x, p1.y);

    // Convert line to normal form: ax + by + c = 0
    // Find normal to line: negative inverse of original line's slope
    n = new Vector2D(a1.y - a2.y, a2.x - a1.x);
    
    // Determine new c coefficient
    cl = a1.x*a2.y - a2.x*a1.y;

    // Transform cubic coefficients to line's coordinate system and find roots
    // of cubic
    roots = new Polynomial(
        n.dot(c2),
        n.dot(c1),
        n.dot(c0) + cl
    ).getRoots();

    // Any roots in closed interval [0,1] are intersections on Bezier, but
    // might not be on the line segment.
    // Find intersections and calculate point coordinates
    for ( var i = 0; i < roots.length; i++ ) {
        var t = roots[i];

        if ( 0 <= t && t <= 1 ) {
            // We're within the Bezier curve
            // Find point on Bezier
            var p4 = p1.lerp(p2, t);
            var p5 = p2.lerp(p3, t);

            var p6 = p4.lerp(p5, t);

            // See if point is on line segment
            // Had to make special cases for vertical and horizontal lines due
            // to slight errors in calculation of p6
            if ( a1.x == a2.x ) {
                if ( min.y <= p6.y && p6.y <= max.y ) {
                    result.status = "Intersection";
                    result.appendPoint( p6 );
                }
            } else if ( a1.y == a2.y ) {
                if ( min.x <= p6.x && p6.x <= max.x ) {
                    result.status = "Intersection";
                    result.appendPoint( p6 );
                }
            } else if ( p6.gte(min) && p6.lte(max) ) {
                result.status = "Intersection";
                result.appendPoint( p6 );
            }
        }
    }

    return result;
};


/*****
*
*   intersectBezier2Polygon
*
*****/
Intersection.intersectBezier2Polygon = function(p1, p2, p3, points) {
    var result = new Intersection("No Intersection");
    var length = points.length;

    for ( var i = 0; i < length; i++ ) {
        var a1 = points[i];
        var a2 = points[(i+1) % length];
        var inter = Intersection.intersectBezier2Line(p1, p2, p3, a1, a2);

        result.appendPoints(inter.points);
    }

    if ( result.points.length > 0 ) result.status = "Intersection";

    return result;
};


/*****
*
*   intersectBezier2Rectangle
*
*****/
Intersection.intersectBezier2Rectangle = function(p1, p2, p3, r1, r2) {
    var min        = r1.min(r2);
    var max        = r1.max(r2);
    var topRight   = new Point2D( max.x, min.y );
    var bottomLeft = new Point2D( min.x, max.y );
    
    var inter1 = Intersection.intersectBezier2Line(p1, p2, p3, min, topRight);
    var inter2 = Intersection.intersectBezier2Line(p1, p2, p3, topRight, max);
    var inter3 = Intersection.intersectBezier2Line(p1, p2, p3, max, bottomLeft);
    var inter4 = Intersection.intersectBezier2Line(p1, p2, p3, bottomLeft, min);
    
    var result = new Intersection("No Intersection");

    result.appendPoints(inter1.points);
    result.appendPoints(inter2.points);
    result.appendPoints(inter3.points);
    result.appendPoints(inter4.points);

    if ( result.points.length > 0 ) result.status = "Intersection";

    return result;
};


/*****
*
*   intersectBezier3Bezier3
*
*****/
Intersection.intersectBezier3Bezier3 = function(a1, a2, a3, a4, b1, b2, b3, b4) {
    var a, b, c, d;         // temporary variables
    var c13, c12, c11, c10; // coefficients of cubic
    var c23, c22, c21, c20; // coefficients of cubic
    var result = new Intersection("No Intersection");

    // Calculate the coefficients of cubic polynomial
    a = a1.multiply(-1);
    b = a2.multiply(3);
    c = a3.multiply(-3);
    d = a.add(b.add(c.add(a4)));
    c13 = new Vector2D(d.x, d.y);

    a = a1.multiply(3);
    b = a2.multiply(-6);
    c = a3.multiply(3);
    d = a.add(b.add(c));
    c12 = new Vector2D(d.x, d.y);

    a = a1.multiply(-3);
    b = a2.multiply(3);
    c = a.add(b);
    c11 = new Vector2D(c.x, c.y);

    c10 = new Vector2D(a1.x, a1.y);

    a = b1.multiply(-1);
    b = b2.multiply(3);
    c = b3.multiply(-3);
    d = a.add(b.add(c.add(b4)));
    c23 = new Vector2D(d.x, d.y);

    a = b1.multiply(3);
    b = b2.multiply(-6);
    c = b3.multiply(3);
    d = a.add(b.add(c));
    c22 = new Vector2D(d.x, d.y);

    a = b1.multiply(-3);
    b = b2.multiply(3);
    c = a.add(b);
    c21 = new Vector2D(c.x, c.y);

    c20 = new Vector2D(b1.x, b1.y);

    var c10x2 = c10.x*c10.x;
    var c10x3 = c10.x*c10.x*c10.x;
    var c10y2 = c10.y*c10.y;
    var c10y3 = c10.y*c10.y*c10.y;
    var c11x2 = c11.x*c11.x;
    var c11x3 = c11.x*c11.x*c11.x;
    var c11y2 = c11.y*c11.y;
    var c11y3 = c11.y*c11.y*c11.y;
    var c12x2 = c12.x*c12.x;
    var c12x3 = c12.x*c12.x*c12.x;
    var c12y2 = c12.y*c12.y;
    var c12y3 = c12.y*c12.y*c12.y;
    var c13x2 = c13.x*c13.x;
    var c13x3 = c13.x*c13.x*c13.x;
    var c13y2 = c13.y*c13.y;
    var c13y3 = c13.y*c13.y*c13.y;
    var c20x2 = c20.x*c20.x;
    var c20x3 = c20.x*c20.x*c20.x;
    var c20y2 = c20.y*c20.y;
    var c20y3 = c20.y*c20.y*c20.y;
    var c21x2 = c21.x*c21.x;
    var c21x3 = c21.x*c21.x*c21.x;
    var c21y2 = c21.y*c21.y;
    var c22x2 = c22.x*c22.x;
    var c22x3 = c22.x*c22.x*c22.x;
    var c22y2 = c22.y*c22.y;
    var c23x2 = c23.x*c23.x;
    var c23x3 = c23.x*c23.x*c23.x;
    var c23y2 = c23.y*c23.y;
    var c23y3 = c23.y*c23.y*c23.y;
    var poly = new Polynomial(
        -c13x3*c23y3 + c13y3*c23x3 - 3*c13.x*c13y2*c23x2*c23.y +
            3*c13x2*c13.y*c23.x*c23y2,
        -6*c13.x*c22.x*c13y2*c23.x*c23.y + 6*c13x2*c13.y*c22.y*c23.x*c23.y + 3*c22.x*c13y3*c23x2 -
            3*c13x3*c22.y*c23y2 - 3*c13.x*c13y2*c22.y*c23x2 + 3*c13x2*c22.x*c13.y*c23y2,
        -6*c21.x*c13.x*c13y2*c23.x*c23.y - 6*c13.x*c22.x*c13y2*c22.y*c23.x + 6*c13x2*c22.x*c13.y*c22.y*c23.y +
            3*c21.x*c13y3*c23x2 + 3*c22x2*c13y3*c23.x + 3*c21.x*c13x2*c13.y*c23y2 - 3*c13.x*c21.y*c13y2*c23x2 -
            3*c13.x*c22x2*c13y2*c23.y + c13x2*c13.y*c23.x*(6*c21.y*c23.y + 3*c22y2) + c13x3*(-c21.y*c23y2 -
            2*c22y2*c23.y - c23.y*(2*c21.y*c23.y + c22y2)),
        c11.x*c12.y*c13.x*c13.y*c23.x*c23.y - c11.y*c12.x*c13.x*c13.y*c23.x*c23.y + 6*c21.x*c22.x*c13y3*c23.x +
            3*c11.x*c12.x*c13.x*c13.y*c23y2 + 6*c10.x*c13.x*c13y2*c23.x*c23.y - 3*c11.x*c12.x*c13y2*c23.x*c23.y -
            3*c11.y*c12.y*c13.x*c13.y*c23x2 - 6*c10.y*c13x2*c13.y*c23.x*c23.y - 6*c20.x*c13.x*c13y2*c23.x*c23.y +
            3*c11.y*c12.y*c13x2*c23.x*c23.y - 2*c12.x*c12y2*c13.x*c23.x*c23.y - 6*c21.x*c13.x*c22.x*c13y2*c23.y -
            6*c21.x*c13.x*c13y2*c22.y*c23.x - 6*c13.x*c21.y*c22.x*c13y2*c23.x + 6*c21.x*c13x2*c13.y*c22.y*c23.y +
            2*c12x2*c12.y*c13.y*c23.x*c23.y + c22x3*c13y3 - 3*c10.x*c13y3*c23x2 + 3*c10.y*c13x3*c23y2 +
            3*c20.x*c13y3*c23x2 + c12y3*c13.x*c23x2 - c12x3*c13.y*c23y2 - 3*c10.x*c13x2*c13.y*c23y2 +
            3*c10.y*c13.x*c13y2*c23x2 - 2*c11.x*c12.y*c13x2*c23y2 + c11.x*c12.y*c13y2*c23x2 - c11.y*c12.x*c13x2*c23y2 +
            2*c11.y*c12.x*c13y2*c23x2 + 3*c20.x*c13x2*c13.y*c23y2 - c12.x*c12y2*c13.y*c23x2 -
            3*c20.y*c13.x*c13y2*c23x2 + c12x2*c12.y*c13.x*c23y2 - 3*c13.x*c22x2*c13y2*c22.y +
            c13x2*c13.y*c23.x*(6*c20.y*c23.y + 6*c21.y*c22.y) + c13x2*c22.x*c13.y*(6*c21.y*c23.y + 3*c22y2) +
            c13x3*(-2*c21.y*c22.y*c23.y - c20.y*c23y2 - c22.y*(2*c21.y*c23.y + c22y2) - c23.y*(2*c20.y*c23.y + 2*c21.y*c22.y)),
        6*c11.x*c12.x*c13.x*c13.y*c22.y*c23.y + c11.x*c12.y*c13.x*c22.x*c13.y*c23.y + c11.x*c12.y*c13.x*c13.y*c22.y*c23.x -
            c11.y*c12.x*c13.x*c22.x*c13.y*c23.y - c11.y*c12.x*c13.x*c13.y*c22.y*c23.x - 6*c11.y*c12.y*c13.x*c22.x*c13.y*c23.x -
            6*c10.x*c22.x*c13y3*c23.x + 6*c20.x*c22.x*c13y3*c23.x + 6*c10.y*c13x3*c22.y*c23.y + 2*c12y3*c13.x*c22.x*c23.x -
            2*c12x3*c13.y*c22.y*c23.y + 6*c10.x*c13.x*c22.x*c13y2*c23.y + 6*c10.x*c13.x*c13y2*c22.y*c23.x +
            6*c10.y*c13.x*c22.x*c13y2*c23.x - 3*c11.x*c12.x*c22.x*c13y2*c23.y - 3*c11.x*c12.x*c13y2*c22.y*c23.x +
            2*c11.x*c12.y*c22.x*c13y2*c23.x + 4*c11.y*c12.x*c22.x*c13y2*c23.x - 6*c10.x*c13x2*c13.y*c22.y*c23.y -
            6*c10.y*c13x2*c22.x*c13.y*c23.y - 6*c10.y*c13x2*c13.y*c22.y*c23.x - 4*c11.x*c12.y*c13x2*c22.y*c23.y -
            6*c20.x*c13.x*c22.x*c13y2*c23.y - 6*c20.x*c13.x*c13y2*c22.y*c23.x - 2*c11.y*c12.x*c13x2*c22.y*c23.y +
            3*c11.y*c12.y*c13x2*c22.x*c23.y + 3*c11.y*c12.y*c13x2*c22.y*c23.x - 2*c12.x*c12y2*c13.x*c22.x*c23.y -
            2*c12.x*c12y2*c13.x*c22.y*c23.x - 2*c12.x*c12y2*c22.x*c13.y*c23.x - 6*c20.y*c13.x*c22.x*c13y2*c23.x -
            6*c21.x*c13.x*c21.y*c13y2*c23.x - 6*c21.x*c13.x*c22.x*c13y2*c22.y + 6*c20.x*c13x2*c13.y*c22.y*c23.y +
            2*c12x2*c12.y*c13.x*c22.y*c23.y + 2*c12x2*c12.y*c22.x*c13.y*c23.y + 2*c12x2*c12.y*c13.y*c22.y*c23.x +
            3*c21.x*c22x2*c13y3 + 3*c21x2*c13y3*c23.x - 3*c13.x*c21.y*c22x2*c13y2 - 3*c21x2*c13.x*c13y2*c23.y +
            c13x2*c22.x*c13.y*(6*c20.y*c23.y + 6*c21.y*c22.y) + c13x2*c13.y*c23.x*(6*c20.y*c22.y + 3*c21y2) +
            c21.x*c13x2*c13.y*(6*c21.y*c23.y + 3*c22y2) + c13x3*(-2*c20.y*c22.y*c23.y - c23.y*(2*c20.y*c22.y + c21y2) -
            c21.y*(2*c21.y*c23.y + c22y2) - c22.y*(2*c20.y*c23.y + 2*c21.y*c22.y)),
        c11.x*c21.x*c12.y*c13.x*c13.y*c23.y + c11.x*c12.y*c13.x*c21.y*c13.y*c23.x + c11.x*c12.y*c13.x*c22.x*c13.y*c22.y -
            c11.y*c12.x*c21.x*c13.x*c13.y*c23.y - c11.y*c12.x*c13.x*c21.y*c13.y*c23.x - c11.y*c12.x*c13.x*c22.x*c13.y*c22.y -
            6*c11.y*c21.x*c12.y*c13.x*c13.y*c23.x - 6*c10.x*c21.x*c13y3*c23.x + 6*c20.x*c21.x*c13y3*c23.x +
            2*c21.x*c12y3*c13.x*c23.x + 6*c10.x*c21.x*c13.x*c13y2*c23.y + 6*c10.x*c13.x*c21.y*c13y2*c23.x +
            6*c10.x*c13.x*c22.x*c13y2*c22.y + 6*c10.y*c21.x*c13.x*c13y2*c23.x - 3*c11.x*c12.x*c21.x*c13y2*c23.y -
            3*c11.x*c12.x*c21.y*c13y2*c23.x - 3*c11.x*c12.x*c22.x*c13y2*c22.y + 2*c11.x*c21.x*c12.y*c13y2*c23.x +
            4*c11.y*c12.x*c21.x*c13y2*c23.x - 6*c10.y*c21.x*c13x2*c13.y*c23.y - 6*c10.y*c13x2*c21.y*c13.y*c23.x -
            6*c10.y*c13x2*c22.x*c13.y*c22.y - 6*c20.x*c21.x*c13.x*c13y2*c23.y - 6*c20.x*c13.x*c21.y*c13y2*c23.x -
            6*c20.x*c13.x*c22.x*c13y2*c22.y + 3*c11.y*c21.x*c12.y*c13x2*c23.y - 3*c11.y*c12.y*c13.x*c22x2*c13.y +
            3*c11.y*c12.y*c13x2*c21.y*c23.x + 3*c11.y*c12.y*c13x2*c22.x*c22.y - 2*c12.x*c21.x*c12y2*c13.x*c23.y -
            2*c12.x*c21.x*c12y2*c13.y*c23.x - 2*c12.x*c12y2*c13.x*c21.y*c23.x - 2*c12.x*c12y2*c13.x*c22.x*c22.y -
            6*c20.y*c21.x*c13.x*c13y2*c23.x - 6*c21.x*c13.x*c21.y*c22.x*c13y2 + 6*c20.y*c13x2*c21.y*c13.y*c23.x +
            2*c12x2*c21.x*c12.y*c13.y*c23.y + 2*c12x2*c12.y*c21.y*c13.y*c23.x + 2*c12x2*c12.y*c22.x*c13.y*c22.y -
            3*c10.x*c22x2*c13y3 + 3*c20.x*c22x2*c13y3 + 3*c21x2*c22.x*c13y3 + c12y3*c13.x*c22x2 +
            3*c10.y*c13.x*c22x2*c13y2 + c11.x*c12.y*c22x2*c13y2 + 2*c11.y*c12.x*c22x2*c13y2 -
            c12.x*c12y2*c22x2*c13.y - 3*c20.y*c13.x*c22x2*c13y2 - 3*c21x2*c13.x*c13y2*c22.y +
            c12x2*c12.y*c13.x*(2*c21.y*c23.y + c22y2) + c11.x*c12.x*c13.x*c13.y*(6*c21.y*c23.y + 3*c22y2) +
            c21.x*c13x2*c13.y*(6*c20.y*c23.y + 6*c21.y*c22.y) + c12x3*c13.y*(-2*c21.y*c23.y - c22y2) +
            c10.y*c13x3*(6*c21.y*c23.y + 3*c22y2) + c11.y*c12.x*c13x2*(-2*c21.y*c23.y - c22y2) +
            c11.x*c12.y*c13x2*(-4*c21.y*c23.y - 2*c22y2) + c10.x*c13x2*c13.y*(-6*c21.y*c23.y - 3*c22y2) +
            c13x2*c22.x*c13.y*(6*c20.y*c22.y + 3*c21y2) + c20.x*c13x2*c13.y*(6*c21.y*c23.y + 3*c22y2) +
            c13x3*(-2*c20.y*c21.y*c23.y - c22.y*(2*c20.y*c22.y + c21y2) - c20.y*(2*c21.y*c23.y + c22y2) -
            c21.y*(2*c20.y*c23.y + 2*c21.y*c22.y)),
        -c10.x*c11.x*c12.y*c13.x*c13.y*c23.y + c10.x*c11.y*c12.x*c13.x*c13.y*c23.y + 6*c10.x*c11.y*c12.y*c13.x*c13.y*c23.x -
            6*c10.y*c11.x*c12.x*c13.x*c13.y*c23.y - c10.y*c11.x*c12.y*c13.x*c13.y*c23.x + c10.y*c11.y*c12.x*c13.x*c13.y*c23.x +
            c11.x*c11.y*c12.x*c12.y*c13.x*c23.y - c11.x*c11.y*c12.x*c12.y*c13.y*c23.x + c11.x*c20.x*c12.y*c13.x*c13.y*c23.y +
            c11.x*c20.y*c12.y*c13.x*c13.y*c23.x + c11.x*c21.x*c12.y*c13.x*c13.y*c22.y + c11.x*c12.y*c13.x*c21.y*c22.x*c13.y -
            c20.x*c11.y*c12.x*c13.x*c13.y*c23.y - 6*c20.x*c11.y*c12.y*c13.x*c13.y*c23.x - c11.y*c12.x*c20.y*c13.x*c13.y*c23.x -
            c11.y*c12.x*c21.x*c13.x*c13.y*c22.y - c11.y*c12.x*c13.x*c21.y*c22.x*c13.y - 6*c11.y*c21.x*c12.y*c13.x*c22.x*c13.y -
            6*c10.x*c20.x*c13y3*c23.x - 6*c10.x*c21.x*c22.x*c13y3 - 2*c10.x*c12y3*c13.x*c23.x + 6*c20.x*c21.x*c22.x*c13y3 +
            2*c20.x*c12y3*c13.x*c23.x + 2*c21.x*c12y3*c13.x*c22.x + 2*c10.y*c12x3*c13.y*c23.y - 6*c10.x*c10.y*c13.x*c13y2*c23.x +
            3*c10.x*c11.x*c12.x*c13y2*c23.y - 2*c10.x*c11.x*c12.y*c13y2*c23.x - 4*c10.x*c11.y*c12.x*c13y2*c23.x +
            3*c10.y*c11.x*c12.x*c13y2*c23.x + 6*c10.x*c10.y*c13x2*c13.y*c23.y + 6*c10.x*c20.x*c13.x*c13y2*c23.y -
            3*c10.x*c11.y*c12.y*c13x2*c23.y + 2*c10.x*c12.x*c12y2*c13.x*c23.y + 2*c10.x*c12.x*c12y2*c13.y*c23.x +
            6*c10.x*c20.y*c13.x*c13y2*c23.x + 6*c10.x*c21.x*c13.x*c13y2*c22.y + 6*c10.x*c13.x*c21.y*c22.x*c13y2 +
            4*c10.y*c11.x*c12.y*c13x2*c23.y + 6*c10.y*c20.x*c13.x*c13y2*c23.x + 2*c10.y*c11.y*c12.x*c13x2*c23.y -
            3*c10.y*c11.y*c12.y*c13x2*c23.x + 2*c10.y*c12.x*c12y2*c13.x*c23.x + 6*c10.y*c21.x*c13.x*c22.x*c13y2 -
            3*c11.x*c20.x*c12.x*c13y2*c23.y + 2*c11.x*c20.x*c12.y*c13y2*c23.x + c11.x*c11.y*c12y2*c13.x*c23.x -
            3*c11.x*c12.x*c20.y*c13y2*c23.x - 3*c11.x*c12.x*c21.x*c13y2*c22.y - 3*c11.x*c12.x*c21.y*c22.x*c13y2 +
            2*c11.x*c21.x*c12.y*c22.x*c13y2 + 4*c20.x*c11.y*c12.x*c13y2*c23.x + 4*c11.y*c12.x*c21.x*c22.x*c13y2 -
            2*c10.x*c12x2*c12.y*c13.y*c23.y - 6*c10.y*c20.x*c13x2*c13.y*c23.y - 6*c10.y*c20.y*c13x2*c13.y*c23.x -
            6*c10.y*c21.x*c13x2*c13.y*c22.y - 2*c10.y*c12x2*c12.y*c13.x*c23.y - 2*c10.y*c12x2*c12.y*c13.y*c23.x -
            6*c10.y*c13x2*c21.y*c22.x*c13.y - c11.x*c11.y*c12x2*c13.y*c23.y - 2*c11.x*c11y2*c13.x*c13.y*c23.x +
            3*c20.x*c11.y*c12.y*c13x2*c23.y - 2*c20.x*c12.x*c12y2*c13.x*c23.y - 2*c20.x*c12.x*c12y2*c13.y*c23.x -
            6*c20.x*c20.y*c13.x*c13y2*c23.x - 6*c20.x*c21.x*c13.x*c13y2*c22.y - 6*c20.x*c13.x*c21.y*c22.x*c13y2 +
            3*c11.y*c20.y*c12.y*c13x2*c23.x + 3*c11.y*c21.x*c12.y*c13x2*c22.y + 3*c11.y*c12.y*c13x2*c21.y*c22.x -
            2*c12.x*c20.y*c12y2*c13.x*c23.x - 2*c12.x*c21.x*c12y2*c13.x*c22.y - 2*c12.x*c21.x*c12y2*c22.x*c13.y -
            2*c12.x*c12y2*c13.x*c21.y*c22.x - 6*c20.y*c21.x*c13.x*c22.x*c13y2 - c11y2*c12.x*c12.y*c13.x*c23.x +
            2*c20.x*c12x2*c12.y*c13.y*c23.y + 6*c20.y*c13x2*c21.y*c22.x*c13.y + 2*c11x2*c11.y*c13.x*c13.y*c23.y +
            c11x2*c12.x*c12.y*c13.y*c23.y + 2*c12x2*c20.y*c12.y*c13.y*c23.x + 2*c12x2*c21.x*c12.y*c13.y*c22.y +
            2*c12x2*c12.y*c21.y*c22.x*c13.y + c21x3*c13y3 + 3*c10x2*c13y3*c23.x - 3*c10y2*c13x3*c23.y +
            3*c20x2*c13y3*c23.x + c11y3*c13x2*c23.x - c11x3*c13y2*c23.y - c11.x*c11y2*c13x2*c23.y +
            c11x2*c11.y*c13y2*c23.x - 3*c10x2*c13.x*c13y2*c23.y + 3*c10y2*c13x2*c13.y*c23.x - c11x2*c12y2*c13.x*c23.y +
            c11y2*c12x2*c13.y*c23.x - 3*c21x2*c13.x*c21.y*c13y2 - 3*c20x2*c13.x*c13y2*c23.y + 3*c20y2*c13x2*c13.y*c23.x +
            c11.x*c12.x*c13.x*c13.y*(6*c20.y*c23.y + 6*c21.y*c22.y) + c12x3*c13.y*(-2*c20.y*c23.y - 2*c21.y*c22.y) +
            c10.y*c13x3*(6*c20.y*c23.y + 6*c21.y*c22.y) + c11.y*c12.x*c13x2*(-2*c20.y*c23.y - 2*c21.y*c22.y) +
            c12x2*c12.y*c13.x*(2*c20.y*c23.y + 2*c21.y*c22.y) + c11.x*c12.y*c13x2*(-4*c20.y*c23.y - 4*c21.y*c22.y) +
            c10.x*c13x2*c13.y*(-6*c20.y*c23.y - 6*c21.y*c22.y) + c20.x*c13x2*c13.y*(6*c20.y*c23.y + 6*c21.y*c22.y) +
            c21.x*c13x2*c13.y*(6*c20.y*c22.y + 3*c21y2) + c13x3*(-2*c20.y*c21.y*c22.y - c20y2*c23.y -
            c21.y*(2*c20.y*c22.y + c21y2) - c20.y*(2*c20.y*c23.y + 2*c21.y*c22.y)),
        -c10.x*c11.x*c12.y*c13.x*c13.y*c22.y + c10.x*c11.y*c12.x*c13.x*c13.y*c22.y + 6*c10.x*c11.y*c12.y*c13.x*c22.x*c13.y -
            6*c10.y*c11.x*c12.x*c13.x*c13.y*c22.y - c10.y*c11.x*c12.y*c13.x*c22.x*c13.y + c10.y*c11.y*c12.x*c13.x*c22.x*c13.y +
            c11.x*c11.y*c12.x*c12.y*c13.x*c22.y - c11.x*c11.y*c12.x*c12.y*c22.x*c13.y + c11.x*c20.x*c12.y*c13.x*c13.y*c22.y +
            c11.x*c20.y*c12.y*c13.x*c22.x*c13.y + c11.x*c21.x*c12.y*c13.x*c21.y*c13.y - c20.x*c11.y*c12.x*c13.x*c13.y*c22.y -
            6*c20.x*c11.y*c12.y*c13.x*c22.x*c13.y - c11.y*c12.x*c20.y*c13.x*c22.x*c13.y - c11.y*c12.x*c21.x*c13.x*c21.y*c13.y -
            6*c10.x*c20.x*c22.x*c13y3 - 2*c10.x*c12y3*c13.x*c22.x + 2*c20.x*c12y3*c13.x*c22.x + 2*c10.y*c12x3*c13.y*c22.y -
            6*c10.x*c10.y*c13.x*c22.x*c13y2 + 3*c10.x*c11.x*c12.x*c13y2*c22.y - 2*c10.x*c11.x*c12.y*c22.x*c13y2 -
            4*c10.x*c11.y*c12.x*c22.x*c13y2 + 3*c10.y*c11.x*c12.x*c22.x*c13y2 + 6*c10.x*c10.y*c13x2*c13.y*c22.y +
            6*c10.x*c20.x*c13.x*c13y2*c22.y - 3*c10.x*c11.y*c12.y*c13x2*c22.y + 2*c10.x*c12.x*c12y2*c13.x*c22.y +
            2*c10.x*c12.x*c12y2*c22.x*c13.y + 6*c10.x*c20.y*c13.x*c22.x*c13y2 + 6*c10.x*c21.x*c13.x*c21.y*c13y2 +
            4*c10.y*c11.x*c12.y*c13x2*c22.y + 6*c10.y*c20.x*c13.x*c22.x*c13y2 + 2*c10.y*c11.y*c12.x*c13x2*c22.y -
            3*c10.y*c11.y*c12.y*c13x2*c22.x + 2*c10.y*c12.x*c12y2*c13.x*c22.x - 3*c11.x*c20.x*c12.x*c13y2*c22.y +
            2*c11.x*c20.x*c12.y*c22.x*c13y2 + c11.x*c11.y*c12y2*c13.x*c22.x - 3*c11.x*c12.x*c20.y*c22.x*c13y2 -
            3*c11.x*c12.x*c21.x*c21.y*c13y2 + 4*c20.x*c11.y*c12.x*c22.x*c13y2 - 2*c10.x*c12x2*c12.y*c13.y*c22.y -
            6*c10.y*c20.x*c13x2*c13.y*c22.y - 6*c10.y*c20.y*c13x2*c22.x*c13.y - 6*c10.y*c21.x*c13x2*c21.y*c13.y -
            2*c10.y*c12x2*c12.y*c13.x*c22.y - 2*c10.y*c12x2*c12.y*c22.x*c13.y - c11.x*c11.y*c12x2*c13.y*c22.y -
            2*c11.x*c11y2*c13.x*c22.x*c13.y + 3*c20.x*c11.y*c12.y*c13x2*c22.y - 2*c20.x*c12.x*c12y2*c13.x*c22.y -
            2*c20.x*c12.x*c12y2*c22.x*c13.y - 6*c20.x*c20.y*c13.x*c22.x*c13y2 - 6*c20.x*c21.x*c13.x*c21.y*c13y2 +
            3*c11.y*c20.y*c12.y*c13x2*c22.x + 3*c11.y*c21.x*c12.y*c13x2*c21.y - 2*c12.x*c20.y*c12y2*c13.x*c22.x -
            2*c12.x*c21.x*c12y2*c13.x*c21.y - c11y2*c12.x*c12.y*c13.x*c22.x + 2*c20.x*c12x2*c12.y*c13.y*c22.y -
            3*c11.y*c21x2*c12.y*c13.x*c13.y + 6*c20.y*c21.x*c13x2*c21.y*c13.y + 2*c11x2*c11.y*c13.x*c13.y*c22.y +
            c11x2*c12.x*c12.y*c13.y*c22.y + 2*c12x2*c20.y*c12.y*c22.x*c13.y + 2*c12x2*c21.x*c12.y*c21.y*c13.y -
            3*c10.x*c21x2*c13y3 + 3*c20.x*c21x2*c13y3 + 3*c10x2*c22.x*c13y3 - 3*c10y2*c13x3*c22.y + 3*c20x2*c22.x*c13y3 +
            c21x2*c12y3*c13.x + c11y3*c13x2*c22.x - c11x3*c13y2*c22.y + 3*c10.y*c21x2*c13.x*c13y2 -
            c11.x*c11y2*c13x2*c22.y + c11.x*c21x2*c12.y*c13y2 + 2*c11.y*c12.x*c21x2*c13y2 + c11x2*c11.y*c22.x*c13y2 -
            c12.x*c21x2*c12y2*c13.y - 3*c20.y*c21x2*c13.x*c13y2 - 3*c10x2*c13.x*c13y2*c22.y + 3*c10y2*c13x2*c22.x*c13.y -
            c11x2*c12y2*c13.x*c22.y + c11y2*c12x2*c22.x*c13.y - 3*c20x2*c13.x*c13y2*c22.y + 3*c20y2*c13x2*c22.x*c13.y +
            c12x2*c12.y*c13.x*(2*c20.y*c22.y + c21y2) + c11.x*c12.x*c13.x*c13.y*(6*c20.y*c22.y + 3*c21y2) +
            c12x3*c13.y*(-2*c20.y*c22.y - c21y2) + c10.y*c13x3*(6*c20.y*c22.y + 3*c21y2) +
            c11.y*c12.x*c13x2*(-2*c20.y*c22.y - c21y2) + c11.x*c12.y*c13x2*(-4*c20.y*c22.y - 2*c21y2) +
            c10.x*c13x2*c13.y*(-6*c20.y*c22.y - 3*c21y2) + c20.x*c13x2*c13.y*(6*c20.y*c22.y + 3*c21y2) +
            c13x3*(-2*c20.y*c21y2 - c20y2*c22.y - c20.y*(2*c20.y*c22.y + c21y2)),
        -c10.x*c11.x*c12.y*c13.x*c21.y*c13.y + c10.x*c11.y*c12.x*c13.x*c21.y*c13.y + 6*c10.x*c11.y*c21.x*c12.y*c13.x*c13.y -
            6*c10.y*c11.x*c12.x*c13.x*c21.y*c13.y - c10.y*c11.x*c21.x*c12.y*c13.x*c13.y + c10.y*c11.y*c12.x*c21.x*c13.x*c13.y -
            c11.x*c11.y*c12.x*c21.x*c12.y*c13.y + c11.x*c11.y*c12.x*c12.y*c13.x*c21.y + c11.x*c20.x*c12.y*c13.x*c21.y*c13.y +
            6*c11.x*c12.x*c20.y*c13.x*c21.y*c13.y + c11.x*c20.y*c21.x*c12.y*c13.x*c13.y - c20.x*c11.y*c12.x*c13.x*c21.y*c13.y -
            6*c20.x*c11.y*c21.x*c12.y*c13.x*c13.y - c11.y*c12.x*c20.y*c21.x*c13.x*c13.y - 6*c10.x*c20.x*c21.x*c13y3 -
            2*c10.x*c21.x*c12y3*c13.x + 6*c10.y*c20.y*c13x3*c21.y + 2*c20.x*c21.x*c12y3*c13.x + 2*c10.y*c12x3*c21.y*c13.y -
            2*c12x3*c20.y*c21.y*c13.y - 6*c10.x*c10.y*c21.x*c13.x*c13y2 + 3*c10.x*c11.x*c12.x*c21.y*c13y2 -
            2*c10.x*c11.x*c21.x*c12.y*c13y2 - 4*c10.x*c11.y*c12.x*c21.x*c13y2 + 3*c10.y*c11.x*c12.x*c21.x*c13y2 +
            6*c10.x*c10.y*c13x2*c21.y*c13.y + 6*c10.x*c20.x*c13.x*c21.y*c13y2 - 3*c10.x*c11.y*c12.y*c13x2*c21.y +
            2*c10.x*c12.x*c21.x*c12y2*c13.y + 2*c10.x*c12.x*c12y2*c13.x*c21.y + 6*c10.x*c20.y*c21.x*c13.x*c13y2 +
            4*c10.y*c11.x*c12.y*c13x2*c21.y + 6*c10.y*c20.x*c21.x*c13.x*c13y2 + 2*c10.y*c11.y*c12.x*c13x2*c21.y -
            3*c10.y*c11.y*c21.x*c12.y*c13x2 + 2*c10.y*c12.x*c21.x*c12y2*c13.x - 3*c11.x*c20.x*c12.x*c21.y*c13y2 +
            2*c11.x*c20.x*c21.x*c12.y*c13y2 + c11.x*c11.y*c21.x*c12y2*c13.x - 3*c11.x*c12.x*c20.y*c21.x*c13y2 +
            4*c20.x*c11.y*c12.x*c21.x*c13y2 - 6*c10.x*c20.y*c13x2*c21.y*c13.y - 2*c10.x*c12x2*c12.y*c21.y*c13.y -
            6*c10.y*c20.x*c13x2*c21.y*c13.y - 6*c10.y*c20.y*c21.x*c13x2*c13.y - 2*c10.y*c12x2*c21.x*c12.y*c13.y -
            2*c10.y*c12x2*c12.y*c13.x*c21.y - c11.x*c11.y*c12x2*c21.y*c13.y - 4*c11.x*c20.y*c12.y*c13x2*c21.y -
            2*c11.x*c11y2*c21.x*c13.x*c13.y + 3*c20.x*c11.y*c12.y*c13x2*c21.y - 2*c20.x*c12.x*c21.x*c12y2*c13.y -
            2*c20.x*c12.x*c12y2*c13.x*c21.y - 6*c20.x*c20.y*c21.x*c13.x*c13y2 - 2*c11.y*c12.x*c20.y*c13x2*c21.y +
            3*c11.y*c20.y*c21.x*c12.y*c13x2 - 2*c12.x*c20.y*c21.x*c12y2*c13.x - c11y2*c12.x*c21.x*c12.y*c13.x +
            6*c20.x*c20.y*c13x2*c21.y*c13.y + 2*c20.x*c12x2*c12.y*c21.y*c13.y + 2*c11x2*c11.y*c13.x*c21.y*c13.y +
            c11x2*c12.x*c12.y*c21.y*c13.y + 2*c12x2*c20.y*c21.x*c12.y*c13.y + 2*c12x2*c20.y*c12.y*c13.x*c21.y +
            3*c10x2*c21.x*c13y3 - 3*c10y2*c13x3*c21.y + 3*c20x2*c21.x*c13y3 + c11y3*c21.x*c13x2 - c11x3*c21.y*c13y2 -
            3*c20y2*c13x3*c21.y - c11.x*c11y2*c13x2*c21.y + c11x2*c11.y*c21.x*c13y2 - 3*c10x2*c13.x*c21.y*c13y2 +
            3*c10y2*c21.x*c13x2*c13.y - c11x2*c12y2*c13.x*c21.y + c11y2*c12x2*c21.x*c13.y - 3*c20x2*c13.x*c21.y*c13y2 +
            3*c20y2*c21.x*c13x2*c13.y,
        c10.x*c10.y*c11.x*c12.y*c13.x*c13.y - c10.x*c10.y*c11.y*c12.x*c13.x*c13.y + c10.x*c11.x*c11.y*c12.x*c12.y*c13.y -
            c10.y*c11.x*c11.y*c12.x*c12.y*c13.x - c10.x*c11.x*c20.y*c12.y*c13.x*c13.y + 6*c10.x*c20.x*c11.y*c12.y*c13.x*c13.y +
            c10.x*c11.y*c12.x*c20.y*c13.x*c13.y - c10.y*c11.x*c20.x*c12.y*c13.x*c13.y - 6*c10.y*c11.x*c12.x*c20.y*c13.x*c13.y +
            c10.y*c20.x*c11.y*c12.x*c13.x*c13.y - c11.x*c20.x*c11.y*c12.x*c12.y*c13.y + c11.x*c11.y*c12.x*c20.y*c12.y*c13.x +
            c11.x*c20.x*c20.y*c12.y*c13.x*c13.y - c20.x*c11.y*c12.x*c20.y*c13.x*c13.y - 2*c10.x*c20.x*c12y3*c13.x +
            2*c10.y*c12x3*c20.y*c13.y - 3*c10.x*c10.y*c11.x*c12.x*c13y2 - 6*c10.x*c10.y*c20.x*c13.x*c13y2 +
            3*c10.x*c10.y*c11.y*c12.y*c13x2 - 2*c10.x*c10.y*c12.x*c12y2*c13.x - 2*c10.x*c11.x*c20.x*c12.y*c13y2 -
            c10.x*c11.x*c11.y*c12y2*c13.x + 3*c10.x*c11.x*c12.x*c20.y*c13y2 - 4*c10.x*c20.x*c11.y*c12.x*c13y2 +
            3*c10.y*c11.x*c20.x*c12.x*c13y2 + 6*c10.x*c10.y*c20.y*c13x2*c13.y + 2*c10.x*c10.y*c12x2*c12.y*c13.y +
            2*c10.x*c11.x*c11y2*c13.x*c13.y + 2*c10.x*c20.x*c12.x*c12y2*c13.y + 6*c10.x*c20.x*c20.y*c13.x*c13y2 -
            3*c10.x*c11.y*c20.y*c12.y*c13x2 + 2*c10.x*c12.x*c20.y*c12y2*c13.x + c10.x*c11y2*c12.x*c12.y*c13.x +
            c10.y*c11.x*c11.y*c12x2*c13.y + 4*c10.y*c11.x*c20.y*c12.y*c13x2 - 3*c10.y*c20.x*c11.y*c12.y*c13x2 +
            2*c10.y*c20.x*c12.x*c12y2*c13.x + 2*c10.y*c11.y*c12.x*c20.y*c13x2 + c11.x*c20.x*c11.y*c12y2*c13.x -
            3*c11.x*c20.x*c12.x*c20.y*c13y2 - 2*c10.x*c12x2*c20.y*c12.y*c13.y - 6*c10.y*c20.x*c20.y*c13x2*c13.y -
            2*c10.y*c20.x*c12x2*c12.y*c13.y - 2*c10.y*c11x2*c11.y*c13.x*c13.y - c10.y*c11x2*c12.x*c12.y*c13.y -
            2*c10.y*c12x2*c20.y*c12.y*c13.x - 2*c11.x*c20.x*c11y2*c13.x*c13.y - c11.x*c11.y*c12x2*c20.y*c13.y +
            3*c20.x*c11.y*c20.y*c12.y*c13x2 - 2*c20.x*c12.x*c20.y*c12y2*c13.x - c20.x*c11y2*c12.x*c12.y*c13.x +
            3*c10y2*c11.x*c12.x*c13.x*c13.y + 3*c11.x*c12.x*c20y2*c13.x*c13.y + 2*c20.x*c12x2*c20.y*c12.y*c13.y -
            3*c10x2*c11.y*c12.y*c13.x*c13.y + 2*c11x2*c11.y*c20.y*c13.x*c13.y + c11x2*c12.x*c20.y*c12.y*c13.y -
            3*c20x2*c11.y*c12.y*c13.x*c13.y - c10x3*c13y3 + c10y3*c13x3 + c20x3*c13y3 - c20y3*c13x3 -
            3*c10.x*c20x2*c13y3 - c10.x*c11y3*c13x2 + 3*c10x2*c20.x*c13y3 + c10.y*c11x3*c13y2 +
            3*c10.y*c20y2*c13x3 + c20.x*c11y3*c13x2 + c10x2*c12y3*c13.x - 3*c10y2*c20.y*c13x3 - c10y2*c12x3*c13.y +
            c20x2*c12y3*c13.x - c11x3*c20.y*c13y2 - c12x3*c20y2*c13.y - c10.x*c11x2*c11.y*c13y2 +
            c10.y*c11.x*c11y2*c13x2 - 3*c10.x*c10y2*c13x2*c13.y - c10.x*c11y2*c12x2*c13.y + c10.y*c11x2*c12y2*c13.x -
            c11.x*c11y2*c20.y*c13x2 + 3*c10x2*c10.y*c13.x*c13y2 + c10x2*c11.x*c12.y*c13y2 +
            2*c10x2*c11.y*c12.x*c13y2 - 2*c10y2*c11.x*c12.y*c13x2 - c10y2*c11.y*c12.x*c13x2 + c11x2*c20.x*c11.y*c13y2 -
            3*c10.x*c20y2*c13x2*c13.y + 3*c10.y*c20x2*c13.x*c13y2 + c11.x*c20x2*c12.y*c13y2 - 2*c11.x*c20y2*c12.y*c13x2 +
            c20.x*c11y2*c12x2*c13.y - c11.y*c12.x*c20y2*c13x2 - c10x2*c12.x*c12y2*c13.y - 3*c10x2*c20.y*c13.x*c13y2 +
            3*c10y2*c20.x*c13x2*c13.y + c10y2*c12x2*c12.y*c13.x - c11x2*c20.y*c12y2*c13.x + 2*c20x2*c11.y*c12.x*c13y2 +
            3*c20.x*c20y2*c13x2*c13.y - c20x2*c12.x*c12y2*c13.y - 3*c20x2*c20.y*c13.x*c13y2 + c12x2*c20y2*c12.y*c13.x
    );
    var roots = poly.getRootsInInterval(0,1);

    for ( var i = 0; i < roots.length; i++ ) {
        var s = roots[i];
        var xRoots = new Polynomial(
            c13.x,
            c12.x,
            c11.x,
            c10.x - c20.x - s*c21.x - s*s*c22.x - s*s*s*c23.x
        ).getRoots();
        var yRoots = new Polynomial(
            c13.y,
            c12.y,
            c11.y,
            c10.y - c20.y - s*c21.y - s*s*c22.y - s*s*s*c23.y
        ).getRoots();

        if ( xRoots.length > 0 && yRoots.length > 0 ) {
            var TOLERANCE = 1e-4;

            checkRoots:
            for ( var j = 0; j < xRoots.length; j++ ) {
                var xRoot = xRoots[j];
                
                if ( 0 <= xRoot && xRoot <= 1 ) {
                    for ( var k = 0; k < yRoots.length; k++ ) {
                        if ( Math.abs( xRoot - yRoots[k] ) < TOLERANCE ) {
                            result.points.push(
                                c23.multiply(s*s*s).add(c22.multiply(s*s).add(c21.multiply(s).add(c20)))
                            );
                            break checkRoots;
                        }
                    }
                }
            }
        }
    }

    if ( result.points.length > 0 ) result.status = "Intersection";

    return result;
};


/*****
*
*   intersectBezier3Circle
*
*****/
Intersection.intersectBezier3Circle = function(p1, p2, p3, p4, c, r) {
    return Intersection.intersectBezier3Ellipse(p1, p2, p3, p4, c, r, r);
};


/*****
*
*   intersectBezier3Ellipse
*
*****/
Intersection.intersectBezier3Ellipse = function(p1, p2, p3, p4, ec, rx, ry) {
    var a, b, c, d;       // temporary variables
    var c3, c2, c1, c0;   // coefficients of cubic
    var result = new Intersection("No Intersection");

    // Calculate the coefficients of cubic polynomial
    a = p1.multiply(-1);
    b = p2.multiply(3);
    c = p3.multiply(-3);
    d = a.add(b.add(c.add(p4)));
    c3 = new Vector2D(d.x, d.y);

    a = p1.multiply(3);
    b = p2.multiply(-6);
    c = p3.multiply(3);
    d = a.add(b.add(c));
    c2 = new Vector2D(d.x, d.y);

    a = p1.multiply(-3);
    b = p2.multiply(3);
    c = a.add(b);
    c1 = new Vector2D(c.x, c.y);

    c0 = new Vector2D(p1.x, p1.y);

    var rxrx  = rx*rx;
    var ryry  = ry*ry;
    var poly = new Polynomial(
        c3.x*c3.x*ryry + c3.y*c3.y*rxrx,
        2*(c3.x*c2.x*ryry + c3.y*c2.y*rxrx),
        2*(c3.x*c1.x*ryry + c3.y*c1.y*rxrx) + c2.x*c2.x*ryry + c2.y*c2.y*rxrx,
        2*c3.x*ryry*(c0.x - ec.x) + 2*c3.y*rxrx*(c0.y - ec.y) +
            2*(c2.x*c1.x*ryry + c2.y*c1.y*rxrx),
        2*c2.x*ryry*(c0.x - ec.x) + 2*c2.y*rxrx*(c0.y - ec.y) +
            c1.x*c1.x*ryry + c1.y*c1.y*rxrx,
        2*c1.x*ryry*(c0.x - ec.x) + 2*c1.y*rxrx*(c0.y - ec.y),
        c0.x*c0.x*ryry - 2*c0.y*ec.y*rxrx - 2*c0.x*ec.x*ryry +
            c0.y*c0.y*rxrx + ec.x*ec.x*ryry + ec.y*ec.y*rxrx - rxrx*ryry
    );
    var roots = poly.getRootsInInterval(0,1);

    for ( var i = 0; i < roots.length; i++ ) {
        var t = roots[i];

        result.points.push(
            c3.multiply(t*t*t).add(c2.multiply(t*t).add(c1.multiply(t).add(c0)))
        );
    }

    if ( result.points.length > 0 ) result.status = "Intersection";

    return result;
};


/*****
*
*   intersectBezier3Line
*
*   Many thanks to Dan Sunday at SoftSurfer.com.  He gave me a very thorough
*   sketch of the algorithm used here.  Without his help, I'm not sure when I
*   would have figured out this intersection problem.
*
*****/
Intersection.intersectBezier3Line = function(p1, p2, p3, p4, a1, a2) {
    var a, b, c, d;       // temporary variables
    var c3, c2, c1, c0;   // coefficients of cubic
    var cl;               // c coefficient for normal form of line
    var n;                // normal for normal form of line
    var min = a1.min(a2); // used to determine if point is on line segment
    var max = a1.max(a2); // used to determine if point is on line segment
    var result = new Intersection("No Intersection");
    
    // Start with Bezier using Bernstein polynomials for weighting functions:
    //     (1-t^3)P1 + 3t(1-t)^2P2 + 3t^2(1-t)P3 + t^3P4
    //
    // Expand and collect terms to form linear combinations of original Bezier
    // controls.  This ends up with a vector cubic in t:
    //     (-P1+3P2-3P3+P4)t^3 + (3P1-6P2+3P3)t^2 + (-3P1+3P2)t + P1
    //             /\                  /\                /\       /\
    //             ||                  ||                ||       ||
    //             c3                  c2                c1       c0
    
    // Calculate the coefficients
    a = p1.multiply(-1);
    b = p2.multiply(3);
    c = p3.multiply(-3);
    d = a.add(b.add(c.add(p4)));
    c3 = new Vector2D(d.x, d.y);

    a = p1.multiply(3);
    b = p2.multiply(-6);
    c = p3.multiply(3);
    d = a.add(b.add(c));
    c2 = new Vector2D(d.x, d.y);

    a = p1.multiply(-3);
    b = p2.multiply(3);
    c = a.add(b);
    c1 = new Vector2D(c.x, c.y);

    c0 = new Vector2D(p1.x, p1.y);
    
    // Convert line to normal form: ax + by + c = 0
    // Find normal to line: negative inverse of original line's slope
    n = new Vector2D(a1.y - a2.y, a2.x - a1.x);
    
    // Determine new c coefficient
    cl = a1.x*a2.y - a2.x*a1.y;

    // ?Rotate each cubic coefficient using line for new coordinate system?
    // Find roots of rotated cubic
    roots = new Polynomial(
        n.dot(c3),
        n.dot(c2),
        n.dot(c1),
        n.dot(c0) + cl
    ).getRoots();

    // Any roots in closed interval [0,1] are intersections on Bezier, but
    // might not be on the line segment.
    // Find intersections and calculate point coordinates
    for ( var i = 0; i < roots.length; i++ ) {
        var t = roots[i];

        if ( 0 <= t && t <= 1 ) {
            // We're within the Bezier curve
            // Find point on Bezier
            var p5 = p1.lerp(p2, t);
            var p6 = p2.lerp(p3, t);
            var p7 = p3.lerp(p4, t);

            var p8 = p5.lerp(p6, t);
            var p9 = p6.lerp(p7, t);

            var p10 = p8.lerp(p9, t);

            // See if point is on line segment
            // Had to make special cases for vertical and horizontal lines due
            // to slight errors in calculation of p10
            if ( a1.x == a2.x ) {
                if ( min.y <= p10.y && p10.y <= max.y ) {
                    result.status = "Intersection";
                    result.appendPoint( p10 );
                }
            } else if ( a1.y == a2.y ) {
                if ( min.x <= p10.x && p10.x <= max.x ) {
                    result.status = "Intersection";
                    result.appendPoint( p10 );
                }
            } else if ( p10.gte(min) && p10.lte(max) ) {
                result.status = "Intersection";
                result.appendPoint( p10 );
            }
        }
    }

    return result;
};


/*****
*
*   intersectBezier3Polygon
*
*****/
Intersection.intersectBezier3Polygon = function(p1, p2, p3, p4, points) {
    var result = new Intersection("No Intersection");
    var length = points.length;

    for ( var i = 0; i < length; i++ ) {
        var a1 = points[i];
        var a2 = points[(i+1) % length];
        var inter = Intersection.intersectBezier3Line(p1, p2, p3, p4, a1, a2);

        result.appendPoints(inter.points);
    }

    if ( result.points.length > 0 ) result.status = "Intersection";

    return result;
};


/*****
*
*   intersectBezier3Rectangle
*
*****/
Intersection.intersectBezier3Rectangle = function(p1, p2, p3, p4, r1, r2) {
    var min        = r1.min(r2);
    var max        = r1.max(r2);
    var topRight   = new Point2D( max.x, min.y );
    var bottomLeft = new Point2D( min.x, max.y );
    
    var inter1 = Intersection.intersectBezier3Line(p1, p2, p3, p4, min, topRight);
    var inter2 = Intersection.intersectBezier3Line(p1, p2, p3, p4, topRight, max);
    var inter3 = Intersection.intersectBezier3Line(p1, p2, p3, p4, max, bottomLeft);
    var inter4 = Intersection.intersectBezier3Line(p1, p2, p3, p4, bottomLeft, min);
    
    var result = new Intersection("No Intersection");

    result.appendPoints(inter1.points);
    result.appendPoints(inter2.points);
    result.appendPoints(inter3.points);
    result.appendPoints(inter4.points);

    if ( result.points.length > 0 ) result.status = "Intersection";

    return result;
};


/*****
*
*   intersectCircleCircle
*
*****/
Intersection.intersectCircleCircle = function(c1, r1, c2, r2) {
    var result;
    
    // Determine minimum and maximum radii where circles can intersect
    var r_max = r1 + r2;
    var r_min = Math.abs(r1 - r2);
    
    // Determine actual distance between circle circles
    var c_dist = c1.distanceFrom( c2 );

    if ( c_dist > r_max ) {
        result = new Intersection("Outside");
    } else if ( c_dist < r_min ) {
        result = new Intersection("Inside");
    } else {
        result = new Intersection("Intersection");

        var a = (r1*r1 - r2*r2 + c_dist*c_dist) / ( 2*c_dist );
        var h = Math.sqrt(r1*r1 - a*a);
        var p = c1.lerp(c2, a/c_dist);
        var b = h / c_dist;

        result.points.push(
            new Point2D(
                p.x - b * (c2.y - c1.y),
                p.y + b * (c2.x - c1.x)
            )
        );
        result.points.push(
            new Point2D(
                p.x + b * (c2.y - c1.y),
                p.y - b * (c2.x - c1.x)
            )
        );
    }

    return result;
};


/*****
*
*   intersectCircleEllipse
*
*****/
Intersection.intersectCircleEllipse = function(cc, r, ec, rx, ry) {
    return Intersection.intersectEllipseEllipse(cc, r, r, ec, rx, ry);
};


/*****
*
*   intersectCircleLine
*
*****/
Intersection.intersectCircleLine = function(c, r, a1, a2) {
    var result;
    var a  = (a2.x - a1.x) * (a2.x - a1.x) +
             (a2.y - a1.y) * (a2.y - a1.y);
    var b  = 2 * ( (a2.x - a1.x) * (a1.x - c.x) +
                   (a2.y - a1.y) * (a1.y - c.y)   );
    var cc = c.x*c.x + c.y*c.y + a1.x*a1.x + a1.y*a1.y -
             2 * (c.x * a1.x + c.y * a1.y) - r*r;
    var deter = b*b - 4*a*cc;

    if ( deter < 0 ) {
        result = new Intersection("Outside");
    } else if ( deter == 0 ) {
        result = new Intersection("Tangent");
        // NOTE: should calculate this point
    } else {
        var e  = Math.sqrt(deter);
        var u1 = ( -b + e ) / ( 2*a );
        var u2 = ( -b - e ) / ( 2*a );

        if ( (u1 < 0 || u1 > 1) && (u2 < 0 || u2 > 1) ) {
            if ( (u1 < 0 && u2 < 0) || (u1 > 1 && u2 > 1) ) {
                result = new Intersection("Outside");
            } else {
                result = new Intersection("Inside");
            }
        } else {
            result = new Intersection("Intersection");

            if ( 0 <= u1 && u1 <= 1)
                result.points.push( a1.lerp(a2, u1) );

            if ( 0 <= u2 && u2 <= 1)
                result.points.push( a1.lerp(a2, u2) );
        }
    }
    
    return result;
};


/*****
*
*   intersectCirclePolygon
*
*****/
Intersection.intersectCirclePolygon = function(c, r, points) {
    var result = new Intersection("No Intersection");
    var length = points.length;
    var inter;

    for ( var i = 0; i < length; i++ ) {
        var a1 = points[i];
        var a2 = points[(i+1) % length];

        inter = Intersection.intersectCircleLine(c, r, a1, a2);
        result.appendPoints(inter.points);
    }

    if ( result.points.length > 0 )
        result.status = "Intersection";
    else
        result.status = inter.status;

    return result;
};


/*****
*
*   intersectCircleRectangle
*
*****/
Intersection.intersectCircleRectangle = function(c, r, r1, r2) {
    var min        = r1.min(r2);
    var max        = r1.max(r2);
    var topRight   = new Point2D( max.x, min.y );
    var bottomLeft = new Point2D( min.x, max.y );
    
    var inter1 = Intersection.intersectCircleLine(c, r, min, topRight);
    var inter2 = Intersection.intersectCircleLine(c, r, topRight, max);
    var inter3 = Intersection.intersectCircleLine(c, r, max, bottomLeft);
    var inter4 = Intersection.intersectCircleLine(c, r, bottomLeft, min);
    
    var result = new Intersection("No Intersection");

    result.appendPoints(inter1.points);
    result.appendPoints(inter2.points);
    result.appendPoints(inter3.points);
    result.appendPoints(inter4.points);

    if ( result.points.length > 0 )
        result.status = "Intersection";
    else
        result.status = inter1.status;

    return result;
};


/*****
*
*   intersectEllipseEllipse
*   
*   This code is based on MgcIntr2DElpElp.cpp written by David Eberly.  His
*   code along with many other excellent examples are avaiable at his site:
*   http://www.magic-software.com
*
*   NOTE: Rotation will need to be added to this function
*
*****/
Intersection.intersectEllipseEllipse = function(c1, rx1, ry1, c2, rx2, ry2) {
    var a = [
        ry1*ry1, 0, rx1*rx1, -2*ry1*ry1*c1.x, -2*rx1*rx1*c1.y,
        ry1*ry1*c1.x*c1.x + rx1*rx1*c1.y*c1.y - rx1*rx1*ry1*ry1
    ];
    var b = [
        ry2*ry2, 0, rx2*rx2, -2*ry2*ry2*c2.x, -2*rx2*rx2*c2.y,
        ry2*ry2*c2.x*c2.x + rx2*rx2*c2.y*c2.y - rx2*rx2*ry2*ry2
    ];

    var yPoly   = Intersection.bezout(a, b);
    var yRoots  = yPoly.getRoots();
    var epsilon = 1e-3;
    var norm0   = ( a[0]*a[0] + 2*a[1]*a[1] + a[2]*a[2] ) * epsilon;
    var norm1   = ( b[0]*b[0] + 2*b[1]*b[1] + b[2]*b[2] ) * epsilon;
    var result  = new Intersection("No Intersection");

    for ( var y = 0; y < yRoots.length; y++ ) {
        var xPoly = new Polynomial(
            a[0],
            a[3] + yRoots[y] * a[1],
            a[5] + yRoots[y] * (a[4] + yRoots[y]*a[2])
        );
        var xRoots = xPoly.getRoots();

        for ( var x = 0; x < xRoots.length; x++ ) {
            var test =
                ( a[0]*xRoots[x] + a[1]*yRoots[y] + a[3] ) * xRoots[x] + 
                ( a[2]*yRoots[y] + a[4] ) * yRoots[y] + a[5];
            if ( Math.abs(test) < norm0 ) {
                test =
                    ( b[0]*xRoots[x] + b[1]*yRoots[y] + b[3] ) * xRoots[x] +
                    ( b[2]*yRoots[y] + b[4] ) * yRoots[y] + b[5];
                if ( Math.abs(test) < norm1 ) {
                    result.appendPoint( new Point2D( xRoots[x], yRoots[y] ) );
                }
            }
        }
    }

    if ( result.points.length > 0 ) result.status = "Intersection";

    return result;
};


/*****
*
*   intersectEllipseLine
*   
*   NOTE: Rotation will need to be added to this function
*
*****/
Intersection.intersectEllipseLine = function(c, rx, ry, a1, a2) {
    var result;
    var origin = new Vector2D(a1.x, a1.y);
    var dir    = Vector2D.fromPoints(a1, a2);
    var center = new Vector2D(c.x, c.y);
    var diff   = origin.subtract(center);
    var mDir   = new Vector2D( dir.x/(rx*rx),  dir.y/(ry*ry)  );
    var mDiff  = new Vector2D( diff.x/(rx*rx), diff.y/(ry*ry) );

    var a = dir.dot(mDir);
    var b = dir.dot(mDiff);
    var c = diff.dot(mDiff) - 1.0;
    var d = b*b - a*c;

    if ( d < 0 ) {
        result = new Intersection("Outside");
    } else if ( d > 0 ) {
        var root = Math.sqrt(d);
        var t_a  = (-b - root) / a;
        var t_b  = (-b + root) / a;

        if ( (t_a < 0 || 1 < t_a) && (t_b < 0 || 1 < t_b) ) {
            if ( (t_a < 0 && t_b < 0) || (t_a > 1 && t_b > 1) )
                result = new Intersection("Outside");
            else
                result = new Intersection("Inside");
        } else {
            result = new Intersection("Intersection");
            if ( 0 <= t_a && t_a <= 1 )
                result.appendPoint( a1.lerp(a2, t_a) );
            if ( 0 <= t_b && t_b <= 1 )
                result.appendPoint( a1.lerp(a2, t_b) );
        }
    } else {
        var t = -b/a;
        if ( 0 <= t && t <= 1 ) {
            result = new Intersection("Intersection");
            result.appendPoint( a1.lerp(a2, t) );
        } else {
            result = new Intersection("Outside");
        }
    }
    
    return result;
};


/*****
*
*   intersectEllipsePolygon
*
*****/
Intersection.intersectEllipsePolygon = function(c, rx, ry, points) {
    var result = new Intersection("No Intersection");
    var length = points.length;

    for ( var i = 0; i < length; i++ ) {
        var b1 = points[i];
        var b2 = points[(i+1) % length];
        var inter = Intersection.intersectEllipseLine(c, rx, ry, b1, b2);

        result.appendPoints(inter.points);
    }

    if ( result.points.length > 0 )
        result.status = "Intersection";

    return result;
};


/*****
*
*   intersectEllipseRectangle
*
*****/
Intersection.intersectEllipseRectangle = function(c, rx, ry, r1, r2) {
    var min        = r1.min(r2);
    var max        = r1.max(r2);
    var topRight   = new Point2D( max.x, min.y );
    var bottomLeft = new Point2D( min.x, max.y );
    
    var inter1 = Intersection.intersectEllipseLine(c, rx, ry, min, topRight);
    var inter2 = Intersection.intersectEllipseLine(c, rx, ry, topRight, max);
    var inter3 = Intersection.intersectEllipseLine(c, rx, ry, max, bottomLeft);
    var inter4 = Intersection.intersectEllipseLine(c, rx, ry, bottomLeft, min);
    
    var result = new Intersection("No Intersection");

    result.appendPoints(inter1.points);
    result.appendPoints(inter2.points);
    result.appendPoints(inter3.points);
    result.appendPoints(inter4.points);

    if ( result.points.length > 0 )
        result.status = "Intersection";

    return result;
};


/*****
*
*   intersectLineLine
*
*****/
Intersection.intersectLineLine = function(a1, a2, b1, b2) {
    var result;
    
    var ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);
    var ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x);
    var u_b  = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);

    if ( u_b != 0 ) {
        var ua = ua_t / u_b;
        var ub = ub_t / u_b;

        if ( 0 <= ua && ua <= 1 && 0 <= ub && ub <= 1 ) {
            result = new Intersection("Intersection");
            result.points.push(
                new Point2D(
                    a1.x + ua * (a2.x - a1.x),
                    a1.y + ua * (a2.y - a1.y)
                )
            );
        } else {
            result = new Intersection("No Intersection");
        }
    } else {
        if ( ua_t == 0 || ub_t == 0 ) {
            result = new Intersection("Coincident");
        } else {
            result = new Intersection("Parallel");
        }
    }

    return result;
};


/*****
*
*   intersectLinePolygon
*
*****/
Intersection.intersectLinePolygon = function(a1, a2, points) {
    var result = new Intersection("No Intersection");
    var length = points.length;

    for ( var i = 0; i < length; i++ ) {
        var b1 = points[i];
        var b2 = points[(i+1) % length];
        var inter = Intersection.intersectLineLine(a1, a2, b1, b2);

        result.appendPoints(inter.points);
    }

    if ( result.points.length > 0 ) result.status = "Intersection";

    return result;
};


/*****
*
*   intersectLineRectangle
*
*****/
Intersection.intersectLineRectangle = function(a1, a2, r1, r2) {
    var min        = r1.min(r2);
    var max        = r1.max(r2);
    var topRight   = new Point2D( max.x, min.y );
    var bottomLeft = new Point2D( min.x, max.y );
    
    var inter1 = Intersection.intersectLineLine(min, topRight, a1, a2);
    var inter2 = Intersection.intersectLineLine(topRight, max, a1, a2);
    var inter3 = Intersection.intersectLineLine(max, bottomLeft, a1, a2);
    var inter4 = Intersection.intersectLineLine(bottomLeft, min, a1, a2);
    
    var result = new Intersection("No Intersection");

    result.appendPoints(inter1.points);
    result.appendPoints(inter2.points);
    result.appendPoints(inter3.points);
    result.appendPoints(inter4.points);

    if ( result.points.length > 0 )
        result.status = "Intersection";

    return result;
};


/*****
*
*   intersectPolygonPolygon
*
*****/
Intersection.intersectPolygonPolygon = function(points1, points2) {
    var result = new Intersection("No Intersection");
    var length = points1.length;

    for ( var i = 0; i < length; i++ ) {
        var a1 = points1[i];
        var a2 = points1[(i+1) % length];
        var inter = Intersection.intersectLinePolygon(a1, a2, points2);

        result.appendPoints(inter.points);
    }

    if ( result.points.length > 0 )
        result.status = "Intersection";

    return result;

};


/*****
*
*   intersectPolygonRectangle
*
*****/
Intersection.intersectPolygonRectangle = function(points, r1, r2) {
    var min        = r1.min(r2);
    var max        = r1.max(r2);
    var topRight   = new Point2D( max.x, min.y );
    var bottomLeft = new Point2D( min.x, max.y );
    
    var inter1 = Intersection.intersectLinePolygon(min, topRight, points);
    var inter2 = Intersection.intersectLinePolygon(topRight, max, points);
    var inter3 = Intersection.intersectLinePolygon(max, bottomLeft, points);
    var inter4 = Intersection.intersectLinePolygon(bottomLeft, min, points);
    
    var result = new Intersection("No Intersection");

    result.appendPoints(inter1.points);
    result.appendPoints(inter2.points);
    result.appendPoints(inter3.points);
    result.appendPoints(inter4.points);

    if ( result.points.length > 0 )
        result.status = "Intersection";

    return result;
};


/*****
*
*   intersectRayRay
*
*****/
Intersection.intersectRayRay = function(a1, a2, b1, b2) {
    var result;
    
    var ua_t = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);
    var ub_t = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x);
    var u_b  = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);

    if ( u_b != 0 ) {
        var ua = ua_t / u_b;

        result = new Intersection("Intersection");
        result.points.push(
            new Point2D(
                a1.x + ua * (a2.x - a1.x),
                a1.y + ua * (a2.y - a1.y)
            )
        );
    } else {
        if ( ua_t == 0 || ub_t == 0 ) {
            result = new Intersection("Coincident");
        } else {
            result = new Intersection("Parallel");
        }
    }

    return result;
};


/*****
*
*   intersectRectangleRectangle
*
*****/
Intersection.intersectRectangleRectangle = function(a1, a2, b1, b2) {
    var min        = a1.min(a2);
    var max        = a1.max(a2);
    var topRight   = new Point2D( max.x, min.y );
    var bottomLeft = new Point2D( min.x, max.y );
    
    var inter1 = Intersection.intersectLineRectangle(min, topRight, b1, b2);
    var inter2 = Intersection.intersectLineRectangle(topRight, max, b1, b2);
    var inter3 = Intersection.intersectLineRectangle(max, bottomLeft, b1, b2);
    var inter4 = Intersection.intersectLineRectangle(bottomLeft, min, b1, b2);
    
    var result = new Intersection("No Intersection");

    result.appendPoints(inter1.points);
    result.appendPoints(inter2.points);
    result.appendPoints(inter3.points);
    result.appendPoints(inter4.points);

    if ( result.points.length > 0 )
        result.status = "Intersection";

    return result;
};


/*****
*
*   bezout
*
*   This code is based on MgcIntr2DElpElp.cpp written by David Eberly.  His
*   code along with many other excellent examples are avaiable at his site:
*   http://www.magic-software.com
*
*****/
Intersection.bezout = function(e1, e2) {
    var AB    = e1[0]*e2[1] - e2[0]*e1[1];
    var AC    = e1[0]*e2[2] - e2[0]*e1[2];
    var AD    = e1[0]*e2[3] - e2[0]*e1[3];
    var AE    = e1[0]*e2[4] - e2[0]*e1[4];
    var AF    = e1[0]*e2[5] - e2[0]*e1[5];
    var BC    = e1[1]*e2[2] - e2[1]*e1[2];
    var BE    = e1[1]*e2[4] - e2[1]*e1[4];
    var BF    = e1[1]*e2[5] - e2[1]*e1[5];
    var CD    = e1[2]*e2[3] - e2[2]*e1[3];
    var DE    = e1[3]*e2[4] - e2[3]*e1[4];
    var DF    = e1[3]*e2[5] - e2[3]*e1[5];
    var BFpDE = BF + DE;
    var BEmCD = BE - CD;

    return new Polynomial(
        AB*BC - AC*AC,
        AB*BEmCD + AD*BC - 2*AC*AE,
        AB*BFpDE + AD*BEmCD - AE*AE - 2*AC*AF,
        AB*DF + AD*BFpDE - 2*AE*AF,
        AD*DF - AF*AF
    );
};

</script></body> </html>